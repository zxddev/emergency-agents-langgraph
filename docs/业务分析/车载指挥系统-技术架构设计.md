# 车载移动指挥系统 - 技术架构设计

> **文档版本**: v1.0
> **创建日期**: 2025-10-27
> **系统定位**: 县级车载移动应急指挥平台
> **核心特性**: 三阶段运行 + 离线优先 + AI智能推理

---

## 目录
1. [架构总览](#一架构总览)
2. [技术栈选型](#二技术栈选型)
3. [系统分层设计](#三系统分层设计)
4. [数据架构](#四数据架构)
5. [AI推理引擎](#五ai推理引擎)
6. [离线能力设计](#六离线能力设计)
7. [三阶段系统集成](#七三阶段系统集成)
8. [部署架构](#八部署架构)
9. [性能指标](#九性能指标)
10. [安全设计](#十安全设计)

---

## 一、架构总览

### 1.1 系统定位与核心特征

```
车载移动指挥系统 = 县级指挥平台 + 三阶段运行 + 离线优先 + AI增强

核心特征：
├── 多终端适配：墙面大屏 / 车载中控 / 指挥员平板 / 救援队APP
├── 三阶段运行：出发前规划 / 行进中监控 / 现场指挥
├── 离线优先：断网情况下核心功能可用
├── AI智能推理：RAG + KG + 案例库 + GIS + 人文数据
└── 分布式协作：县级系统 ↔ 省级系统数据交换
```

### 1.2 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                       前端展示层 (Presentation)                  │
├─────────────────────────────────────────────────────────────────┤
│ 阶段1: 县应急中心      │ 阶段2: 车载中控     │ 阶段3: 前线指挥部  │
│ - 墙面大屏(React)      │ - 中控屏(React)     │ - 指挥车大屏       │
│ - 规划工作站          │ - 指挥员平板         │ - 指挥员平板       │
│                       │ - 车载HUD            │ - 救援队APP(RN)    │
└─────────────────────────────────────────────────────────────────┘
                              ↓ HTTPS / WebSocket
┌─────────────────────────────────────────────────────────────────┐
│                       API网关层 (Gateway)                        │
├─────────────────────────────────────────────────────────────────┤
│ FastAPI + Nginx + Kong                                          │
│ - 路由分发    - 认证鉴权    - 限流熔断    - 日志追踪            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    业务服务层 (Services)                         │
├──────────────────┬──────────────────┬──────────────────────────┤
│ 规划服务         │ 监控服务          │ 指挥服务                 │
│ - 灾情评估       │ - 无人机侦查      │ - 任务分配               │
│ - 装备推荐       │ - 危险预警        │ - 进度跟踪               │
│ - 路线规划       │ - 路线调整        │ - 资源调度               │
│ - 目标识别       │ - 车队管理        │ - 上报管理               │
└──────────────────┴──────────────────┴──────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    AI推理层 (Intelligence)                       │
├──────────────────┬──────────────────┬──────────────────────────┤
│ RAG检索引擎      │ KG推理引擎        │ GIS分析引擎              │
│ - Qdrant向量库   │ - Neo4j图数据库   │ - PostGIS空间分析       │
│ - BGE-M3嵌入     │ - 规则推理        │ - 路径规划              │
└──────────────────┴──────────────────┴──────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    数据持久层 (Storage)                          │
├──────────────────┬──────────────────┬──────────────────────────┤
│ PostgreSQL 15    │ Neo4j 5.0        │ Qdrant 1.7               │
│ - 业务数据       │ - 知识图谱        │ - 向量存储               │
│ - 审计日志       │ - 关系推理        │ - RAG检索                │
│ - LangGraph状态  │ - 案例库          │                          │
└──────────────────┴──────────────────┴──────────────────────────┘
```

### 1.3 关键架构决策

| 决策点 | 选择方案 | 理由 |
|--------|---------|------|
| **前端框架** | React 18 + TypeScript | 生态成熟，组件丰富，类型安全 |
| **地图引擎** | MapLibre GL JS + deck.gl | 开源免费，性能优异，3D支持 |
| **后端框架** | FastAPI + Python 3.10 | 异步高性能，类型注解，与AI库兼容 |
| **AI编排** | LangGraph | 状态机编排，支持人工审批中断 |
| **KG数据库** | Neo4j 5.0 | 图查询语言Cypher，推理能力强 |
| **向量数据库** | Qdrant 1.7 | 性能优异，支持过滤，轻量级 |
| **关系数据库** | PostgreSQL 15 + PostGIS | 空间扩展，ACID保证，成熟稳定 |
| **移动端** | React Native | 跨平台，代码复用率高 |
| **离线存储** | SQLite + IndexedDB | 轻量级，嵌入式，支持SQL |
| **消息队列** | Redis Streams | 轻量级，低延迟，持久化 |

---

## 二、技术栈选型

### 2.1 前端技术栈

#### 阶段1: 县应急中心（墙面大屏）
```typescript
// 技术栈
Framework: React 18.2 + TypeScript 5.0
UI Library: Ant Design Pro 5.0
Map Engine: MapLibre GL JS 4.0 + deck.gl 9.0
State: Redux Toolkit + RTK Query
Build: Vite 5.0

// 关键依赖
{
  "react": "^18.2.0",
  "typescript": "^5.0.0",
  "antd": "^5.0.0",
  "@ant-design/pro-components": "^2.0.0",
  "maplibre-gl": "^4.0.0",
  "deck.gl": "^9.0.0",
  "@reduxjs/toolkit": "^2.0.0",
  "vite": "^5.0.0"
}

// 页面结构
src/pages/
├── planning/              # 出发前规划页面
│   ├── DisasterAssessment.tsx    # 灾情评估
│   ├── EquipmentRecommend.tsx    # 装备推荐
│   ├── RouteDesign.tsx           # 路线规划
│   └── TargetIdentify.tsx        # 目标识别
```

#### 阶段2: 车载中控屏（行进中监控）
```typescript
// 特殊优化
- 大字体设计（车载震动环境）
- 语音交互优先（解放双手）
- 高对比度配色（强光环境）
- 触控优化（戴手套操作）

// 关键组件
components/vehicle/
├── DangerAlert.tsx        # 危险预警（L0-L3四级）
├── RouteAdjust.tsx        # 路线调整
├── DroneMonitor.tsx       # 无人机监控
└── ConvoyTracker.tsx      # 车队追踪
```

#### 阶段3: 救援队APP（React Native）
```typescript
// 技术栈
Framework: React Native 0.73
Navigation: React Navigation 6
State: Redux Toolkit + RTK Query
Offline: Redux Persist + SQLite
Map: react-native-maps + Mapbox

// 核心功能
app/
├── TaskReceive/           # 任务接收
├── ProgressReport/        # 进度上报
├── ResourceRequest/       # 资源申请
├── OfflineMode/           # 离线模式
└── VoiceCommand/          # 语音指令
```

### 2.2 后端技术栈

#### 核心服务层
```python
# 技术栈
Framework: FastAPI 0.109
Language: Python 3.10
AI Orchestration: LangGraph 0.2
LLM: GLM-4-Flash (智谱AI)
Embedding: BGE-M3 (智源)
GIS: Geopandas + NetworkX + PostGIS

# 项目结构
src/emergency_agents/
├── api/                   # API路由层
│   ├── planning.py        # 出发前规划API
│   ├── monitoring.py      # 行进中监控API
│   └── commanding.py      # 现场指挥API
├── agents/                # AI智能体
│   ├── disaster_assessor.py      # 灾情评估
│   ├── equipment_recommender.py  # 装备推荐
│   ├── route_planner.py          # 路线规划
│   ├── danger_predictor.py       # 危险预测
│   └── task_allocator.py         # 任务分配
├── rag/                   # RAG检索
│   ├── retriever.py       # 检索器
│   ├── reranker.py        # 重排序
│   └── pipe.py            # 检索管道
├── graph/                 # 知识图谱
│   ├── kg_service.py      # KG查询服务
│   └── kg_seed.py         # 数据初始化
└── geo/                   # GIS服务
    ├── route_optimizer.py # 路径优化
    ├── risk_analyzer.py   # 风险分析
    └── spatial_query.py   # 空间查询
```

#### 依赖清单
```python
# requirements.txt
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.0
pydantic-settings==2.1.0

# AI框架
langgraph==0.2.0
langchain==0.1.0
langchain-openai==0.0.5

# 数据库
psycopg2-binary==2.9.9
neo4j==5.16.0
qdrant-client==1.7.0
redis==5.0.1

# GIS
geopandas==0.14.0
shapely==2.0.2
networkx==3.2.1

# 向量化
sentence-transformers==2.3.0  # BGE-M3
FlagEmbedding==1.2.0

# 工具
httpx==0.26.0
tenacity==8.2.3
loguru==0.7.2
```

### 2.3 数据库技术栈

| 数据库 | 版本 | 用途 | 连接字符串示例 |
|--------|------|------|---------------|
| PostgreSQL | 15.5 | 业务数据、LangGraph checkpoint、审计日志 | `postgresql://rescue:***@8.147.130.215:19532/rescue_system` |
| Neo4j | 5.0 | 知识图谱、装备推理、案例检索 | `bolt://8.147.130.215:7687` |
| Qdrant | 1.7 | 向量存储、RAG检索 | `http://8.147.130.215:6333` |
| Redis | 7.2 | 缓存、会话、消息队列 | `redis://8.147.130.215:6379/0` |
| SQLite | 3.45 | 车载离线存储 | `sqlite:///vehicle.db` |

---

## 三、系统分层设计

### 3.1 API网关层

#### 网关配置（Nginx + Kong）
```nginx
# nginx.conf
upstream backend {
    server 127.0.0.1:8008;  # FastAPI服务
    server 127.0.0.1:8009 backup;  # 备用服务
}

server {
    listen 443 ssl http2;
    server_name rescue-api.example.com;

    # SSL证书
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    # 限流配置
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/s;
    limit_req zone=api_limit burst=200 nodelay;

    # API路由
    location /api/v1/planning {
        proxy_pass http://backend/api/v1/planning;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Request-ID $request_id;
    }

    location /api/v1/monitoring {
        proxy_pass http://backend/api/v1/monitoring;
    }

    location /api/v1/commanding {
        proxy_pass http://backend/api/v1/commanding;
    }

    # WebSocket支持（车队实时追踪）
    location /ws/convoy {
        proxy_pass http://backend/ws/convoy;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

#### 认证鉴权（JWT + RBAC）
```python
# src/emergency_agents/auth/middleware.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt

security = HTTPBearer()

# 角色定义
class Role:
    COMMANDER = "commander"       # 指挥员：全部权限
    COORDINATOR = "coordinator"   # 协调员：只能协调
    RESCUER = "rescuer"          # 救援队员：只能上报进度
    VIEWER = "viewer"            # 观察员：只读权限

# 权限验证
async def verify_role(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    required_role: str = Role.COMMANDER
):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_role = payload.get("role")
        if user_role not in ROLE_HIERARCHY[required_role]:
            raise HTTPException(status_code=403, detail="权限不足")
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="认证失败")

# 使用示例
@app.post("/api/v1/commanding/task/assign")
async def assign_task(
    task: TaskAssignRequest,
    user = Depends(lambda: verify_role(required_role=Role.COMMANDER))
):
    # 只有指挥员可以分配任务
    pass
```

### 3.2 业务服务层

#### 阶段1: 出发前规划服务
```python
# src/emergency_agents/api/planning.py
from fastapi import APIRouter, Depends
from emergency_agents.agents import (
    DisasterAssessor,
    EquipmentRecommender,
    RoutePlanner,
    TargetIdentifier
)

router = APIRouter(prefix="/api/v1/planning", tags=["出发前规划"])

@router.post("/disaster/assess")
async def assess_disaster(request: DisasterInput):
    """
    灾情快速评估
    输入: 震级、震中坐标、初步伤亡
    输出: 结构化灾情数据（受灾范围、人口、建筑类型）
    """
    assessor = DisasterAssessor()
    result = await assessor.assess(
        magnitude=request.magnitude,
        epicenter=request.epicenter,
        casualties=request.casualties
    )
    return result

@router.post("/equipment/recommend")
async def recommend_equipment(request: DisasterContext):
    """
    装备物资智能推荐
    AI推理: RAG + KG + 案例库 + 人文数据
    输出: 装备清单（基础 + 特殊 + 人文）
    """
    recommender = EquipmentRecommender(
        rag_retriever=rag_service,
        kg_engine=kg_service,
        case_db=case_service
    )
    equipment_list = await recommender.recommend(request)
    return {
        "basic_equipment": equipment_list.basic,
        "special_equipment": equipment_list.special,
        "cultural_equipment": equipment_list.cultural,
        "reasoning_chain": equipment_list.reasoning  # 推理过程
    }

@router.post("/route/plan")
async def plan_route(request: RouteRequest):
    """
    行进路线规划
    输入: 起点、终点、车队配置
    输出: 主路线 + 备用路线 + 风险标注
    """
    planner = RoutePlanner(gis_service=gis_service)
    routes = await planner.plan(
        origin=request.origin,
        destination=request.destination,
        convoy_config=request.convoy
    )
    return {
        "primary_route": routes.primary,
        "backup_routes": routes.backups,
        "risk_zones": routes.risks,  # L1-L3风险区域
        "estimated_time": routes.eta
    }

@router.post("/target/identify")
async def identify_targets(request: DisasterArea):
    """
    重点目标识别
    输入: 受灾区域范围
    输出: P0-P2优先级目标清单
    """
    identifier = TargetIdentifier(gis_service=gis_service)
    targets = await identifier.identify(request.area)
    return {
        "p0_targets": targets.p0,  # 化工厂、加油站、大坝
        "p1_targets": targets.p1,  # 学校、医院
        "p2_targets": targets.p2,  # 桥梁、主干道
        "rationale": targets.reasoning
    }
```

#### 阶段2: 行进中监控服务
```python
# src/emergency_agents/api/monitoring.py
from fastapi import APIRouter, WebSocket
from emergency_agents.agents import (
    DangerPredictor,
    RouteAdjuster,
    DroneController,
    ConvoyManager
)

router = APIRouter(prefix="/api/v1/monitoring", tags=["行进中监控"])

@router.websocket("/ws/convoy/{convoy_id}")
async def convoy_realtime(websocket: WebSocket, convoy_id: str):
    """
    车队实时追踪（WebSocket）
    推送频率: 1次/秒
    数据: 位置、速度、车间距、前方路况
    """
    await websocket.accept()
    convoy_mgr = ConvoyManager(convoy_id)

    try:
        while True:
            convoy_status = await convoy_mgr.get_status()
            await websocket.send_json({
                "vehicles": convoy_status.vehicles,  # 每辆车位置
                "formation": convoy_status.formation,  # 编队状态
                "leader": convoy_status.leader,  # 领队车辆
                "road_condition": convoy_status.road  # 前方路况
            })
            await asyncio.sleep(1)
    except WebSocketDisconnect:
        await convoy_mgr.cleanup()

@router.post("/danger/predict")
async def predict_danger(request: LocationContext):
    """
    危险预测（L0-L3分级）
    数据源: 无人机 + 交警 + 地震局 + 气象局
    输出: 危险等级 + 预警信息 + 应对建议
    """
    predictor = DangerPredictor(
        drone_data=drone_service,
        traffic_data=traffic_service,
        seismic_data=seismic_service,
        weather_data=weather_service
    )
    result = await predictor.predict(request.location)

    # 危险等级判定
    if result.level == "L3":  # 危急
        # 自动发送强警报到车载中控
        await alert_service.send_critical_alert(
            convoy_id=request.convoy_id,
            message="前方10km发现大面积塌方，立即停车！",
            sound="critical_alarm.mp3"
        )

    return {
        "level": result.level,  # L0/L1/L2/L3
        "threats": result.threats,  # 威胁列表
        "suggestion": result.suggestion,  # 应对建议
        "updated_at": result.timestamp
    }

@router.post("/route/adjust")
async def adjust_route(request: HazardReport):
    """
    动态路线调整
    触发条件: L2/L3危险 or 第三方通报
    输出: 新路线 + 绕行方案
    """
    adjuster = RouteAdjuster(gis_service=gis_service)
    new_route = await adjuster.adjust(
        current_location=request.location,
        hazard=request.hazard,
        convoy_speed=request.speed
    )
    return {
        "status": "route_changed",
        "new_route": new_route.path,
        "detour_distance": new_route.extra_km,
        "detour_time": new_route.extra_minutes,
        "reason": new_route.reason
    }

@router.post("/drone/scout")
async def scout_ahead(request: ScoutRequest):
    """
    无人机前置侦查
    范围: 前方10km
    频率: 每5分钟一次
    """
    controller = DroneController()
    scout_result = await controller.scout(
        current_location=request.location,
        direction=request.direction,
        range_km=10
    )
    return {
        "images": scout_result.images,  # 航拍图像
        "road_condition": scout_result.road,  # 道路状况
        "obstacles": scout_result.obstacles,  # 障碍物
        "safe_to_proceed": scout_result.is_safe
    }
```

#### 阶段3: 现场指挥服务
```python
# src/emergency_agents/api/commanding.py
from fastapi import APIRouter
from emergency_agents.agents import (
    CommandAuthorityManager,
    TaskAllocator,
    ProgressTracker,
    ReportGenerator
)

router = APIRouter(prefix="/api/v1/commanding", tags=["现场指挥"])

@router.post("/authority/takeover")
async def takeover_command(request: RescuerCheckIn):
    """
    指挥权接管（三层体系）
    输入: 救援人员信息（姓名、单位、资质）
    输出: 指挥层级（直接指挥/协调/信息上报）
    """
    authority_mgr = CommandAuthorityManager()
    authority = await authority_mgr.assign_authority(
        rescuer_id=request.rescuer_id,
        unit=request.unit,
        qualification=request.qualification
    )

    # 三层体系判定
    if request.unit in ["消防", "武警", "解放军"]:
        level = "DIRECT_COMMAND"  # 层级1：直接指挥
    elif request.unit in ["志愿者", "民间救援队"]:
        level = "COORDINATION"  # 层级2：协调
    else:
        level = "INFORMATION"  # 层级3：信息上报

    return {
        "authority_level": level,
        "permissions": authority.permissions,
        "app_token": authority.token  # 救援队APP登录凭证
    }

@router.post("/task/allocate")
async def allocate_task(request: TaskAllocationRequest):
    """
    任务动态分配
    AI推理: 约束条件检查（资质、装备、体力、位置）
    输出: 任务分配方案
    """
    allocator = TaskAllocator(
        kg_service=kg_service,  # 知识图谱（资质要求）
        gis_service=gis_service  # 空间距离
    )
    allocation = await allocator.allocate(
        task=request.task,
        available_rescuers=request.rescuers
    )

    # 推送任务到救援队APP
    for assignment in allocation.assignments:
        await push_service.send_task(
            rescuer_id=assignment.rescuer_id,
            task=assignment.task,
            deadline=assignment.deadline
        )

    return {
        "allocations": allocation.assignments,
        "unassigned_tasks": allocation.unassigned,
        "reasoning": allocation.reasoning
    }

@router.post("/progress/track")
async def track_progress(report: ProgressReport):
    """
    进度跟踪（救援队APP上报）
    频率: 每30分钟一次
    """
    tracker = ProgressTracker()
    await tracker.update_progress(
        task_id=report.task_id,
        status=report.status,
        completion=report.completion_percent,
        notes=report.notes
    )
    return {"status": "updated"}

@router.post("/report/generate")
async def generate_report(request: ReportRequest):
    """
    向省级上报（格式化报告）
    内容: 灾情概况、救援进度、资源需求
    """
    generator = ReportGenerator()
    report = await generator.generate(
        disaster_summary=request.disaster,
        rescue_progress=request.progress,
        resource_needs=request.needs
    )

    # 推送到省级指挥大厅
    await provincial_api.submit_report(
        report_id=report.id,
        content=report.content,
        attachments=report.attachments  # 现场照片/视频
    )

    return {
        "report_id": report.id,
        "submitted_at": report.timestamp,
        "status": "delivered_to_provincial"
    }
```

### 3.3 AI推理层

#### RAG检索引擎
```python
# src/emergency_agents/rag/pipe.py
from langchain_openai import OpenAIEmbeddings
from qdrant_client import QdrantClient
from langchain.retrievers import EnsembleRetriever

class RescueRAGPipeline:
    def __init__(self):
        # BGE-M3嵌入模型（智源）
        self.embeddings = OpenAIEmbeddings(
            model="BAAI/bge-m3",
            base_url="http://localhost:8000/v1"  # vLLM部署
        )

        # Qdrant向量库（按Domain分类）
        self.qdrant = QdrantClient(url="http://8.147.130.215:6333")
        self.collections = {
            "standards": "rescue_standards",      # 救援规范
            "cases": "historical_cases",          # 历史案例
            "equipment": "equipment_manual",      # 装备手册
            "geography": "geographic_data"        # 地理数据
        }

    async def retrieve(
        self,
        query: str,
        domain: str,
        top_k: int = 5,
        filters: dict = None
    ):
        """
        RAG检索（支持过滤）

        示例1: 检索装备标准
        query = "地震救援需要哪些装备？"
        domain = "standards"

        示例2: 检索历史案例（带过滤）
        query = "山区地震救援案例"
        domain = "cases"
        filters = {"disaster_type": "earthquake", "terrain": "mountain"}
        """
        # 向量检索
        collection = self.collections[domain]
        query_vector = self.embeddings.embed_query(query)

        results = self.qdrant.search(
            collection_name=collection,
            query_vector=query_vector,
            limit=top_k,
            query_filter=filters
        )

        # 重排序（BGE Reranker）
        reranked = await self.rerank(query, results)

        return {
            "documents": [r.payload for r in reranked],
            "scores": [r.score for r in reranked],
            "sources": [r.metadata.source for r in reranked]
        }

    async def rerank(self, query: str, candidates: list):
        """使用BGE Reranker重排序"""
        from FlagEmbedding import FlagReranker

        reranker = FlagReranker('BAAI/bge-reranker-v2-m3', use_fp16=True)
        scores = reranker.compute_score(
            [[query, cand.payload['text']] for cand in candidates]
        )

        # 按得分排序
        ranked = sorted(
            zip(candidates, scores),
            key=lambda x: x[1],
            reverse=True
        )
        return [cand for cand, score in ranked]
```

#### 知识图谱推理引擎
```python
# src/emergency_agents/graph/kg_service.py
from neo4j import AsyncGraphDatabase

class KnowledgeGraphService:
    def __init__(self):
        self.driver = AsyncGraphDatabase.driver(
            "bolt://8.147.130.215:7687",
            auth=("neo4j", "example-neo4j")
        )

    async def infer_equipment(self, disaster_context: dict):
        """
        装备推理（防幻觉）

        推理链示例:
        灾区有化工厂 → 化工厂生产氯气 → 氯气有毒 → 需要防化服
        """
        async with self.driver.session() as session:
            query = """
            MATCH (d:Disaster {type: $disaster_type})-[:AFFECTS]->(t:Target)
            MATCH (t)-[:PRODUCES]->(c:Chemical)
            MATCH (c)-[:REQUIRES]->(e:Equipment)
            RETURN t.name AS target, c.name AS chemical,
                   c.toxicity AS toxicity, e.name AS equipment,
                   e.spec AS spec
            """
            result = await session.run(
                query,
                disaster_type=disaster_context['type']
            )

            equipment_chain = []
            async for record in result:
                equipment_chain.append({
                    "target": record["target"],
                    "chemical": record["chemical"],
                    "toxicity": record["toxicity"],
                    "equipment": record["equipment"],
                    "spec": record["spec"],
                    "reasoning": f"{record['target']}生产{record['chemical']}"
                                f"（毒性{record['toxicity']}），需要{record['equipment']}"
                })

            return equipment_chain

    async def find_similar_cases(self, disaster: dict, top_k: int = 3):
        """
        历史案例检索（基于图相似度）
        """
        async with self.driver.session() as session:
            query = """
            MATCH (d1:Disaster {
                type: $disaster_type,
                magnitude: $magnitude
            })
            MATCH (d2:Disaster)
            WHERE d2.type = d1.type
              AND abs(d2.magnitude - d1.magnitude) <= 1.0
            MATCH (d2)-[:HAS_LESSON]->(l:Lesson)
            RETURN d2.name AS case_name,
                   d2.date AS date,
                   d2.location AS location,
                   collect(l.content) AS lessons
            ORDER BY d2.casualties DESC
            LIMIT $top_k
            """
            result = await session.run(
                query,
                disaster_type=disaster['type'],
                magnitude=disaster['magnitude'],
                top_k=top_k
            )

            cases = []
            async for record in result:
                cases.append({
                    "name": record["case_name"],
                    "date": record["date"],
                    "location": record["location"],
                    "lessons": record["lessons"]
                })

            return cases
```

#### GIS分析引擎
```python
# src/emergency_agents/geo/route_optimizer.py
import geopandas as gpd
import networkx as nx
from shapely.geometry import Point, LineString

class RouteOptimizer:
    def __init__(self, gis_service):
        self.gis = gis_service
        self.graph = None  # 道路网络图

    async def optimize_route(
        self,
        origin: tuple,  # (lon, lat)
        destination: tuple,
        constraints: dict
    ):
        """
        路径优化（考虑风险）

        约束条件:
        - 车队宽度（不能过窄的道路）
        - 车队高度（不能过低的桥梁）
        - 风险等级（避开L2/L3区域）
        """
        # 1. 构建道路网络图
        await self._build_road_network(origin, destination)

        # 2. 标注风险权重
        await self._annotate_risks()

        # 3. Dijkstra最短路径（考虑风险权重）
        path = nx.dijkstra_path(
            self.graph,
            source=self._nearest_node(origin),
            target=self._nearest_node(destination),
            weight=self._risk_weighted_distance
        )

        # 4. 生成备用路线（次优路径）
        backup_paths = list(nx.shortest_simple_paths(
            self.graph,
            source=self._nearest_node(origin),
            target=self._nearest_node(destination),
            weight=self._risk_weighted_distance
        ))[:3]  # 取前3条备用路线

        return {
            "primary": self._path_to_geometry(path),
            "backups": [self._path_to_geometry(p) for p in backup_paths],
            "risks": await self._identify_risk_zones(path),
            "eta": self._calculate_eta(path, constraints['speed'])
        }

    def _risk_weighted_distance(self, u, v, edge_data):
        """
        风险加权距离
        距离 × 风险系数
        L0: 1.0, L1: 1.2, L2: 2.0, L3: 10.0（几乎不走）
        """
        distance = edge_data['length']
        risk_level = edge_data.get('risk_level', 'L0')
        risk_weights = {'L0': 1.0, 'L1': 1.2, 'L2': 2.0, 'L3': 10.0}
        return distance * risk_weights[risk_level]

    async def _identify_risk_zones(self, path: list):
        """
        识别路径上的风险区域
        数据源: 地震断裂带 + 滑坡易发区 + 洪水淹没区
        """
        risk_zones = []
        path_line = LineString([self.graph.nodes[n]['pos'] for n in path])

        # 空间查询（PostGIS）
        query = """
        SELECT r.type, r.level, ST_AsGeoJSON(r.geom) AS geometry
        FROM risk_zones r
        WHERE ST_Intersects(r.geom, ST_GeomFromText($1, 4326))
        """
        results = await self.gis.query(query, path_line.wkt)

        for row in results:
            risk_zones.append({
                "type": row['type'],
                "level": row['level'],
                "geometry": row['geometry']
            })

        return risk_zones
```

---

## 四、数据架构

### 4.1 PostgreSQL数据库设计

#### 核心表结构
```sql
-- 1. 灾害事件表
CREATE TABLE disasters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,                    -- 事件名称（如"余杭区6.2级地震"）
    type VARCHAR(50) NOT NULL,                     -- 类型（earthquake/flood/landslide）
    magnitude DECIMAL(3,1),                        -- 震级
    epicenter GEOMETRY(POINT, 4326),               -- 震中坐标
    occurred_at TIMESTAMP NOT NULL,                -- 发生时间
    casualties JSONB,                              -- 伤亡情况 {"dead": 10, "injured": 50}
    affected_area GEOMETRY(POLYGON, 4326),         -- 受灾范围
    status VARCHAR(20) DEFAULT 'active',           -- 状态（active/resolved）
    created_at TIMESTAMP DEFAULT NOW()
);

-- 2. 车队表
CREATE TABLE convoys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    disaster_id UUID REFERENCES disasters(id),
    name VARCHAR(100) NOT NULL,                    -- 车队名称
    departure_location GEOMETRY(POINT, 4326),      -- 出发地
    destination GEOMETRY(POINT, 4326),             -- 目的地
    status VARCHAR(20) NOT NULL,                   -- 状态（preparing/traveling/arrived）
    commander_id UUID REFERENCES users(id),        -- 指挥员
    vehicle_count INT NOT NULL,                    -- 车辆数
    personnel_count INT NOT NULL,                  -- 人员数
    departed_at TIMESTAMP,
    arrived_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 3. 车辆表
CREATE TABLE vehicles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    convoy_id UUID REFERENCES convoys(id),
    license_plate VARCHAR(20) NOT NULL,            -- 车牌
    type VARCHAR(50) NOT NULL,                     -- 类型（command/supply/rescue）
    position GEOMETRY(POINT, 4326),                -- 当前位置
    speed DECIMAL(5,2),                            -- 速度（km/h）
    fuel_percent DECIMAL(5,2),                     -- 油量百分比
    status VARCHAR(20) DEFAULT 'normal',           -- 状态（normal/warning/error）
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 4. 重点目标表
CREATE TABLE priority_targets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    disaster_id UUID REFERENCES disasters(id),
    name VARCHAR(200) NOT NULL,                    -- 目标名称
    type VARCHAR(50) NOT NULL,                     -- 类型（chemical_plant/school/bridge）
    priority VARCHAR(5) NOT NULL,                  -- 优先级（P0/P1/P2）
    location GEOMETRY(POINT, 4326),                -- 位置
    status VARCHAR(20) DEFAULT 'pending',          -- 状态（pending/scouting/rescued）
    risk_level VARCHAR(5),                         -- 风险等级（L0-L3）
    population INT,                                -- 涉及人口
    assigned_to UUID REFERENCES tasks(id),         -- 分配的任务
    created_at TIMESTAMP DEFAULT NOW()
);

-- 5. 任务表
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    disaster_id UUID REFERENCES disasters(id),
    target_id UUID REFERENCES priority_targets(id),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL,                     -- 类型（scout/rescue/supply）
    priority VARCHAR(5) NOT NULL,                  -- 优先级（P0/P1/P2）
    status VARCHAR(20) DEFAULT 'pending',          -- 状态（pending/assigned/in_progress/completed）
    assigned_to UUID REFERENCES rescuers(id),
    estimated_hours DECIMAL(5,2),
    actual_hours DECIMAL(5,2),
    progress_percent DECIMAL(5,2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    started_at TIMESTAMP,
    completed_at TIMESTAMP
);

-- 6. 救援人员表
CREATE TABLE rescuers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    unit VARCHAR(200) NOT NULL,                    -- 单位（消防/武警/志愿者）
    authority_level VARCHAR(20) NOT NULL,          -- 权限（DIRECT_COMMAND/COORDINATION/INFORMATION）
    qualification JSONB,                           -- 资质 {"certs": ["高空作业", "潜水"], "experience_years": 5}
    current_location GEOMETRY(POINT, 4326),
    status VARCHAR(20) DEFAULT 'available',        -- 状态（available/busy/resting）
    energy_percent DECIMAL(5,2) DEFAULT 100,       -- 体力百分比
    equipment JSONB,                               -- 携带装备
    created_at TIMESTAMP DEFAULT NOW()
);

-- 7. 进度上报表
CREATE TABLE progress_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id),
    rescuer_id UUID REFERENCES rescuers(id),
    progress_percent DECIMAL(5,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    notes TEXT,
    photos JSONB,                                  -- 现场照片URLs
    location GEOMETRY(POINT, 4326),
    reported_at TIMESTAMP DEFAULT NOW()
);

-- 8. 装备物资表
CREATE TABLE equipment_inventory (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    convoy_id UUID REFERENCES convoys(id),
    name VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,                 -- 类别（basic/special/cultural）
    quantity INT NOT NULL,
    unit VARCHAR(20) NOT NULL,                     -- 单位（件/套/台）
    status VARCHAR(20) DEFAULT 'loaded',           -- 状态（loaded/deployed/consumed）
    location VARCHAR(200),                         -- 存放位置
    created_at TIMESTAMP DEFAULT NOW()
);

-- 9. 风险区域表
CREATE TABLE risk_zones (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    disaster_id UUID REFERENCES disasters(id),
    type VARCHAR(50) NOT NULL,                     -- 类型（landslide/flood/chemical_leak）
    level VARCHAR(5) NOT NULL,                     -- 等级（L0/L1/L2/L3）
    geometry GEOMETRY(POLYGON, 4326),              -- 区域范围
    description TEXT,
    detected_at TIMESTAMP NOT NULL,
    resolved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 10. 审计日志表
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    action VARCHAR(100) NOT NULL,                  -- 操作（assign_task/approve_plan）
    resource_type VARCHAR(50) NOT NULL,
    resource_id UUID NOT NULL,
    changes JSONB,                                 -- 变更内容
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 11. LangGraph检查点表（LangGraph自动管理）
CREATE TABLE langgraph_checkpoints (
    thread_id UUID NOT NULL,
    checkpoint_ns VARCHAR(100) DEFAULT 'default',
    checkpoint_id VARCHAR(100) NOT NULL,
    parent_checkpoint_id VARCHAR(100),
    checkpoint JSONB NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (thread_id, checkpoint_ns, checkpoint_id)
);

-- 索引优化
CREATE INDEX idx_disasters_type ON disasters(type);
CREATE INDEX idx_disasters_status ON disasters(status);
CREATE INDEX idx_disasters_occurred_at ON disasters(occurred_at DESC);
CREATE INDEX idx_vehicles_convoy ON vehicles(convoy_id);
CREATE INDEX idx_vehicles_position ON vehicles USING GIST(position);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_priority ON tasks(priority);
CREATE INDEX idx_rescuers_status ON rescuers(status);
CREATE INDEX idx_rescuers_location ON rescuers USING GIST(current_location);
CREATE INDEX idx_risk_zones_geometry ON risk_zones USING GIST(geometry);
```

#### 空间查询示例
```sql
-- 示例1: 查询震中50km范围内的重点目标
SELECT t.name, t.type, t.priority,
       ST_Distance(t.location, d.epicenter) / 1000 AS distance_km
FROM priority_targets t
JOIN disasters d ON t.disaster_id = d.id
WHERE ST_DWithin(t.location, d.epicenter, 50000)  -- 50km
ORDER BY t.priority, distance_km;

-- 示例2: 查询车辆前方10km的风险区域
WITH vehicle_path AS (
    SELECT ST_Buffer(
        ST_MakeLine(position, ST_Project(position::geography, 10000, radians(heading))::geometry),
        500  -- 左右500米缓冲
    ) AS path_buffer
    FROM vehicles
    WHERE id = 'vehicle_uuid'
)
SELECT r.type, r.level, r.description
FROM risk_zones r, vehicle_path vp
WHERE ST_Intersects(r.geometry, vp.path_buffer)
  AND r.level IN ('L2', 'L3');

-- 示例3: 查询最近的可用救援人员（5km范围内）
SELECT r.name, r.unit, r.authority_level,
       ST_Distance(r.current_location, ST_MakePoint($lon, $lat)) / 1000 AS distance_km
FROM rescuers r
WHERE r.status = 'available'
  AND r.energy_percent >= 50
  AND ST_DWithin(r.current_location, ST_MakePoint($lon, $lat), 5000)
ORDER BY distance_km
LIMIT 10;
```

### 4.2 Neo4j知识图谱设计

#### 节点类型（Nodes）
```cypher
// 1. 灾害类型
(:DisasterType {
    name: "地震",
    characteristics: "突发性、破坏性强、次生灾害多",
    typical_casualties: "高"
})

// 2. 重点目标类型
(:TargetType {
    name: "化工厂",
    priority: "P0",
    typical_risks: ["化学泄漏", "爆炸", "中毒"],
    required_qualifications: ["防化", "危化品处理"]
})

// 3. 装备
(:Equipment {
    name: "防化服（A级）",
    category: "special",
    specs: {
        protection_level: "A",
        suitable_for: ["氯气", "氨气", "硫化氢"],
        max_exposure_time: "4小时"
    },
    weight_kg: 15,
    unit_price: 8000
})

// 4. 化学品
(:Chemical {
    name: "氯气",
    formula: "Cl2",
    toxicity: "剧毒",
    ld50: "293 ppm (1小时)",
    symptoms: ["呼吸困难", "肺水肿", "窒息"],
    antidote: "无特效解毒药，吸氧、激素治疗"
})

// 5. 历史案例
(:HistoricalCase {
    name: "汶川地震",
    date: "2008-05-12",
    magnitude: 8.0,
    location: "四川省汶川县",
    casualties: 69227,
    lessons: [
        "信息盲区严重，需要无人机侦查",
        "交通瓶颈致命，需要预置救援力量",
        "需要统一指挥平台"
    ]
})

// 6. 救援技能
(:Skill {
    name: "高空绳索救援",
    category: "technical",
    training_hours: 80,
    certification_required: true,
    risk_level: "high"
})

// 7. 民族文化
(:Ethnicity {
    name: "藏族",
    customs: {
        religion: "藏传佛教",
        taboos: ["不吃鱼", "天葬神圣"],
        festivals: ["藏历新年", "雪顿节"]
    },
    language: "藏语",
    typical_regions: ["西藏", "四川甘孜", "青海"]
})
```

#### 关系类型（Relationships）
```cypher
// 1. 灾害影响目标
(:DisasterType)-[:AFFECTS {probability: 0.8}]->(:TargetType)

// 2. 目标生产/存储化学品
(:TargetType)-[:PRODUCES {quantity_tons: 500}]->(:Chemical)
(:TargetType)-[:STORES]->(:Chemical)

// 3. 化学品需要装备
(:Chemical)-[:REQUIRES {urgency: "critical"}]->(:Equipment)

// 4. 装备对抗化学品
(:Equipment)-[:PROTECTS_AGAINST {effectiveness: 0.95}]->(:Chemical)

// 5. 任务需要技能
(:TaskType)-[:REQUIRES_SKILL {proficiency: "intermediate"}]->(:Skill)

// 6. 案例提供经验
(:HistoricalCase)-[:HAS_LESSON {importance: "high"}]->(:Lesson)

// 7. 民族聚居区域
(:Ethnicity)-[:INHABITS]->(:Region)

// 8. 装备组合（常用组合）
(:Equipment)-[:OFTEN_WITH {co_occurrence: 0.9}]->(:Equipment)
```

#### 推理查询示例
```cypher
// 推理1: 根据化工厂推断所需装备
MATCH path = (dt:DisasterType {name: "地震"})-[:AFFECTS]->(tt:TargetType {name: "化工厂"})
             -[:PRODUCES]->(c:Chemical)-[:REQUIRES]->(e:Equipment)
RETURN e.name AS equipment,
       e.specs AS specifications,
       c.name AS chemical,
       c.toxicity AS toxicity_level,
       "化工厂生产" + c.name + "（" + c.toxicity + "），需要" + e.name AS reasoning

// 推理2: 查询历史相似案例
MATCH (hc:HistoricalCase)
WHERE hc.magnitude >= $current_magnitude - 1.0
  AND hc.magnitude <= $current_magnitude + 1.0
  AND hc.location CONTAINS $region_keyword
MATCH (hc)-[:HAS_LESSON]->(lesson:Lesson)
RETURN hc.name AS case_name,
       hc.date AS date,
       hc.casualties AS casualties,
       collect(lesson.content) AS lessons
ORDER BY hc.casualties DESC
LIMIT 3

// 推理3: 根据民族推断文化装备
MATCH (e:Ethnicity {name: $ethnicity})
MATCH (e)-[:INHABITS]->(r:Region)
WHERE r.name = $region_name
RETURN e.customs AS customs,
       e.language AS language,
       ["翻译设备", "清真食品", "宗教用品"] AS recommended_equipment,
       "该地区" + e.name + "聚居，需要考虑宗教习俗" AS reasoning

// 推理4: 装备组合推荐（关联规则）
MATCH (e1:Equipment {name: "防化服"})-[r:OFTEN_WITH]->(e2:Equipment)
WHERE r.co_occurrence >= 0.8
RETURN e2.name AS companion_equipment,
       r.co_occurrence AS frequency,
       "使用防化服时，" + toString(toInteger(r.co_occurrence * 100)) + "% 的情况下也需要" + e2.name AS reasoning
ORDER BY r.co_occurrence DESC

// 推理5: 任务技能匹配
MATCH (task:TaskType {name: $task_name})-[:REQUIRES_SKILL]->(skill:Skill)
MATCH (rescuer:Rescuer)-[:HAS_SKILL {proficiency: proficiency}]->(skill)
WHERE proficiency IN ["intermediate", "expert"]
RETURN rescuer.name AS rescuer_name,
       rescuer.unit AS unit,
       collect(skill.name) AS matched_skills,
       rescuer.energy_percent AS energy,
       "具备所需技能: " + reduce(s = "", skill IN collect(skill.name) | s + skill + ", ") AS reasoning
ORDER BY rescuer.energy_percent DESC
```

#### 数据初始化脚本
```python
# src/emergency_agents/graph/kg_seed.py
from neo4j import AsyncGraphDatabase

async def seed_knowledge_graph():
    driver = AsyncGraphDatabase.driver(
        "bolt://8.147.130.215:7687",
        auth=("neo4j", "example-neo4j")
    )

    async with driver.session() as session:
        # 1. 创建灾害类型
        await session.run("""
            CREATE (dt:DisasterType {
                name: "地震",
                characteristics: "突发性、破坏性强、次生灾害多",
                typical_casualties: "高"
            })
        """)

        # 2. 创建目标类型
        await session.run("""
            CREATE (tt:TargetType {
                name: "化工厂",
                priority: "P0",
                typical_risks: ["化学泄漏", "爆炸", "中毒"],
                required_qualifications: ["防化", "危化品处理"]
            })
        """)

        # 3. 创建化学品
        await session.run("""
            CREATE (c:Chemical {
                name: "氯气",
                formula: "Cl2",
                toxicity: "剧毒",
                ld50: "293 ppm (1小时)",
                symptoms: ["呼吸困难", "肺水肿", "窒息"],
                antidote: "无特效解毒药，吸氧、激素治疗"
            })
        """)

        # 4. 创建装备
        await session.run("""
            CREATE (e:Equipment {
                name: "防化服（A级）",
                category: "special",
                protection_level: "A",
                suitable_for: ["氯气", "氨气", "硫化氢"],
                max_exposure_time: "4小时",
                weight_kg: 15,
                unit_price: 8000
            })
        """)

        # 5. 建立关系
        await session.run("""
            MATCH (dt:DisasterType {name: "地震"})
            MATCH (tt:TargetType {name: "化工厂"})
            CREATE (dt)-[:AFFECTS {probability: 0.8}]->(tt)
        """)

        await session.run("""
            MATCH (tt:TargetType {name: "化工厂"})
            MATCH (c:Chemical {name: "氯气"})
            CREATE (tt)-[:PRODUCES {quantity_tons: 500}]->(c)
        """)

        await session.run("""
            MATCH (c:Chemical {name: "氯气"})
            MATCH (e:Equipment {name: "防化服（A级）"})
            CREATE (c)-[:REQUIRES {urgency: "critical"}]->(e)
        """)

        # 6. 导入历史案例
        cases = [
            {
                "name": "汶川地震",
                "date": "2008-05-12",
                "magnitude": 8.0,
                "location": "四川省汶川县",
                "casualties": 69227,
                "lessons": [
                    "信息盲区严重，需要无人机侦查",
                    "交通瓶颈致命，需要预置救援力量",
                    "需要统一指挥平台"
                ]
            },
            {
                "name": "雅安地震",
                "date": "2013-04-20",
                "magnitude": 7.0,
                "location": "四川省雅安市",
                "casualties": 196,
                "lessons": [
                    "无人机2小时获取灾情，效率提升",
                    "救援力量预置机制有效",
                    "通信保障快速恢复"
                ]
            }
        ]

        for case in cases:
            await session.run("""
                CREATE (hc:HistoricalCase {
                    name: $name,
                    date: $date,
                    magnitude: $magnitude,
                    location: $location,
                    casualties: $casualties
                })
                WITH hc
                UNWIND $lessons AS lesson_text
                CREATE (lesson:Lesson {content: lesson_text})
                CREATE (hc)-[:HAS_LESSON {importance: "high"}]->(lesson)
            """, **case)

    await driver.close()
```

### 4.3 Qdrant向量库设计

#### Collection结构
```python
# src/emergency_agents/rag/collections.py
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams, PointStruct

class RescueCollections:
    def __init__(self):
        self.client = QdrantClient(url="http://8.147.130.215:6333")
        self.embedding_dim = 1024  # BGE-M3维度

    async def create_collections(self):
        """创建四个Domain的向量库"""

        # 1. 救援规范Collection
        await self.client.create_collection(
            collection_name="rescue_standards",
            vectors_config=VectorParams(
                size=self.embedding_dim,
                distance=Distance.COSINE
            )
        )

        # 2. 历史案例Collection
        await self.client.create_collection(
            collection_name="historical_cases",
            vectors_config=VectorParams(
                size=self.embedding_dim,
                distance=Distance.COSINE
            )
        )

        # 3. 装备手册Collection
        await self.client.create_collection(
            collection_name="equipment_manual",
            vectors_config=VectorParams(
                size=self.embedding_dim,
                distance=Distance.COSINE
            )
        )

        # 4. 地理数据Collection
        await self.client.create_collection(
            collection_name="geographic_data",
            vectors_config=VectorParams(
                size=self.embedding_dim,
                distance=Distance.COSINE
            )
        )

    async def index_standards(self, documents: list):
        """索引救援规范文档"""
        points = []
        for idx, doc in enumerate(documents):
            point = PointStruct(
                id=idx,
                vector=doc['embedding'],
                payload={
                    "text": doc['text'],
                    "source": doc['source'],  # 如"GB/T 33743-2017 地震应急救援指南"
                    "category": doc['category'],  # "装备标准" / "程序规范" / "安全要求"
                    "keywords": doc['keywords']
                }
            )
            points.append(point)

        await self.client.upsert(
            collection_name="rescue_standards",
            points=points
        )

    async def index_cases(self, cases: list):
        """索引历史案例"""
        points = []
        for idx, case in enumerate(cases):
            point = PointStruct(
                id=idx,
                vector=case['embedding'],
                payload={
                    "text": case['description'],
                    "case_name": case['name'],
                    "date": case['date'],
                    "location": case['location'],
                    "disaster_type": case['type'],  # 可用于过滤
                    "magnitude": case['magnitude'],
                    "casualties": case['casualties'],
                    "lessons": case['lessons']
                }
            )
            points.append(point)

        await self.client.upsert(
            collection_name="historical_cases",
            points=points
        )
```

#### 检索示例
```python
# 示例1: 检索装备标准（无过滤）
query_vector = embeddings.embed_query("地震救援需要哪些装备？")
results = client.search(
    collection_name="rescue_standards",
    query_vector=query_vector,
    limit=5
)

# 示例2: 检索历史案例（带过滤）
query_vector = embeddings.embed_query("山区地震救援经验")
results = client.search(
    collection_name="historical_cases",
    query_vector=query_vector,
    query_filter={
        "must": [
            {"key": "disaster_type", "match": {"value": "earthquake"}},
            {"key": "magnitude", "range": {"gte": 6.0}}
        ]
    },
    limit=3
)

# 示例3: 装备手册检索（带关键词过滤）
query_vector = embeddings.embed_query("防化服使用说明")
results = client.search(
    collection_name="equipment_manual",
    query_vector=query_vector,
    query_filter={
        "must": [
            {"key": "category", "match": {"value": "special"}}
        ]
    },
    limit=5
)
```

---

## 五、AI推理引擎

### 5.1 LangGraph编排架构

#### 状态机定义
```python
# src/emergency_agents/graph/app.py
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.postgres import PostgresSaver
from typing import TypedDict, Annotated, Sequence
import operator

# 1. 定义状态
class RescueState(TypedDict):
    """救援状态（三阶段共享）"""
    # 灾害信息
    disaster_id: str
    disaster_type: str
    magnitude: float
    epicenter: tuple[float, float]

    # 当前阶段
    stage: str  # "planning" / "monitoring" / "commanding"

    # 阶段1: 规划数据
    disaster_assessment: dict
    equipment_recommendation: dict
    route_plan: dict
    priority_targets: list

    # 阶段2: 监控数据
    convoy_id: str
    current_location: tuple[float, float]
    danger_level: str  # L0/L1/L2/L3
    road_condition: dict

    # 阶段3: 指挥数据
    assigned_tasks: list
    rescuer_status: dict
    progress_reports: list

    # 消息历史
    messages: Annotated[Sequence[dict], operator.add]

# 2. 定义节点
async def disaster_assessor_node(state: RescueState):
    """灾情评估节点"""
    from emergency_agents.agents import DisasterAssessor

    assessor = DisasterAssessor()
    assessment = await assessor.assess(
        magnitude=state["magnitude"],
        epicenter=state["epicenter"]
    )

    return {
        "disaster_assessment": assessment,
        "messages": [{"role": "agent", "content": f"灾情评估完成: {assessment}"}]
    }

async def equipment_recommender_node(state: RescueState):
    """装备推荐节点（RAG + KG）"""
    from emergency_agents.agents import EquipmentRecommender

    recommender = EquipmentRecommender()
    equipment = await recommender.recommend(state["disaster_assessment"])

    return {
        "equipment_recommendation": equipment,
        "messages": [{"role": "agent", "content": f"装备推荐: {equipment}"}]
    }

async def route_planner_node(state: RescueState):
    """路线规划节点"""
    from emergency_agents.agents import RoutePlanner

    planner = RoutePlanner()
    routes = await planner.plan(
        disaster_location=state["epicenter"],
        equipment=state["equipment_recommendation"]
    )

    return {
        "route_plan": routes,
        "messages": [{"role": "agent", "content": f"路线规划完成"}]
    }

async def human_approval_node(state: RescueState):
    """
    人工审批中断点（LangGraph核心特性）
    指挥员审批后才能出发
    """
    return {
        "messages": [{"role": "system", "content": "等待指挥员审批..."}]
    }

async def danger_predictor_node(state: RescueState):
    """危险预测节点（行进中）"""
    from emergency_agents.agents import DangerPredictor

    predictor = DangerPredictor()
    danger = await predictor.predict(state["current_location"])

    # 如果L3危急，立即中断并警报
    if danger["level"] == "L3":
        return {
            "danger_level": "L3",
            "messages": [{"role": "alert", "content": "危急警报！立即停车！"}]
        }

    return {
        "danger_level": danger["level"],
        "messages": [{"role": "agent", "content": f"当前危险等级: {danger['level']}"}]
    }

async def task_allocator_node(state: RescueState):
    """任务分配节点（现场指挥）"""
    from emergency_agents.agents import TaskAllocator

    allocator = TaskAllocator()
    allocations = await allocator.allocate(
        targets=state["priority_targets"],
        rescuers=state["rescuer_status"]
    )

    return {
        "assigned_tasks": allocations,
        "messages": [{"role": "agent", "content": f"任务分配完成: {len(allocations)}个任务"}]
    }

# 3. 构建图
def build_rescue_graph():
    """构建救援状态机"""

    # PostgreSQL检查点存储（支持人工中断）
    checkpointer = PostgresSaver.from_conn_string(
        "postgresql://rescue:rescue_password@8.147.130.215:19532/rescue_system"
    )

    # 创建图
    workflow = StateGraph(RescueState)

    # 添加节点（阶段1: 规划）
    workflow.add_node("disaster_assessor", disaster_assessor_node)
    workflow.add_node("equipment_recommender", equipment_recommender_node)
    workflow.add_node("route_planner", route_planner_node)
    workflow.add_node("human_approval", human_approval_node)  # 人工审批

    # 添加节点（阶段2: 监控）
    workflow.add_node("danger_predictor", danger_predictor_node)

    # 添加节点（阶段3: 指挥）
    workflow.add_node("task_allocator", task_allocator_node)

    # 定义边（阶段1流程）
    workflow.add_edge("disaster_assessor", "equipment_recommender")
    workflow.add_edge("equipment_recommender", "route_planner")
    workflow.add_edge("route_planner", "human_approval")  # 规划完成，等待审批

    # 定义条件边（审批后分支）
    workflow.add_conditional_edges(
        "human_approval",
        lambda state: state.get("approval_status", "pending"),
        {
            "approved": "danger_predictor",  # 审批通过，进入阶段2
            "rejected": "equipment_recommender",  # 审批拒绝，重新规划
            "pending": END  # 等待中，中断执行
        }
    )

    # 定义边（阶段2 → 阶段3）
    workflow.add_edge("danger_predictor", "task_allocator")

    # 设置入口点
    workflow.set_entry_point("disaster_assessor")

    # 编译图（带检查点）
    app = workflow.compile(checkpointer=checkpointer)

    return app
```

#### 使用示例
```python
# 启动救援线程（阶段1: 规划）
app = build_rescue_graph()

initial_state = {
    "disaster_id": "disaster_20250127_001",
    "disaster_type": "earthquake",
    "magnitude": 6.5,
    "epicenter": (120.15, 30.28),
    "stage": "planning"
}

config = {
    "configurable": {
        "thread_id": "convoy_alpha_001",
        "checkpoint_ns": "county_yuhang"  # 多租户命名空间
    }
}

# 执行到人工审批节点（自动中断）
result = await app.ainvoke(initial_state, config=config)
# 此时图执行到human_approval节点，等待人工审批

# 指挥员审批通过
approval_update = {
    "approval_status": "approved",
    "approved_by": "commander_wang",
    "approved_at": "2025-01-27T10:30:00Z"
}

# 继续执行（从检查点恢复）
result = await app.ainvoke(approval_update, config=config)
# 图继续执行，进入阶段2（监控）和阶段3（指挥）
```

### 5.2 RAG + KG混合推理

#### 装备推荐推理链
```python
# src/emergency_agents/agents/equipment_recommender.py
from emergency_agents.rag import RescueRAGPipeline
from emergency_agents.graph import KnowledgeGraphService

class EquipmentRecommender:
    def __init__(self):
        self.rag = RescueRAGPipeline()
        self.kg = KnowledgeGraphService()

    async def recommend(self, disaster_context: dict):
        """
        装备推荐（RAG + KG + 案例 + 人文）

        推理流程:
        1. RAG检索 → 基础装备清单（国标）
        2. KG推理 → 特殊装备（化工厂 → 防化服）
        3. 案例匹配 → 经验装备（雅安经验 → 卫星电话）
        4. 人文补充 → 文化装备（藏族 → 翻译设备）
        """
        equipment_list = {
            "basic": [],
            "special": [],
            "cultural": [],
            "reasoning_chain": []
        }

        # 步骤1: RAG检索基础装备
        rag_results = await self.rag.retrieve(
            query=f"{disaster_context['type']}救援需要哪些装备？",
            domain="standards",
            top_k=5
        )

        for doc in rag_results["documents"]:
            # 从国标文档提取装备清单
            equipment_list["basic"].extend(
                self._parse_equipment_from_standard(doc["text"])
            )
            equipment_list["reasoning_chain"].append({
                "step": "RAG检索",
                "source": doc["metadata"]["source"],
                "result": f"根据{doc['metadata']['source']}，需要{equipment_list['basic']}"
            })

        # 步骤2: KG推理特殊装备
        kg_equipment = await self.kg.infer_equipment(disaster_context)

        for item in kg_equipment:
            equipment_list["special"].append({
                "name": item["equipment"],
                "spec": item["spec"],
                "reason": item["reasoning"]
            })
            equipment_list["reasoning_chain"].append({
                "step": "KG推理",
                "reasoning": item["reasoning"],
                "result": item["equipment"]
            })

        # 步骤3: 案例匹配经验装备
        similar_cases = await self.kg.find_similar_cases(
            disaster=disaster_context,
            top_k=3
        )

        for case in similar_cases:
            case_equipment = self._extract_equipment_from_lessons(case["lessons"])
            equipment_list["basic"].extend(case_equipment)
            equipment_list["reasoning_chain"].append({
                "step": "案例匹配",
                "case": case["name"],
                "result": f"{case['name']}经验：增加{case_equipment}"
            })

        # 步骤4: 人文补充文化装备
        if "ethnicity" in disaster_context:
            cultural_equipment = await self._get_cultural_equipment(
                disaster_context["ethnicity"]
            )
            equipment_list["cultural"] = cultural_equipment
            equipment_list["reasoning_chain"].append({
                "step": "人文分析",
                "ethnicity": disaster_context["ethnicity"],
                "result": f"考虑{disaster_context['ethnicity']}习俗，增加{cultural_equipment}"
            })

        # 去重
        equipment_list["basic"] = list(set(equipment_list["basic"]))

        return equipment_list

    def _parse_equipment_from_standard(self, text: str) -> list:
        """从标准文档提取装备清单"""
        # 使用LLM提取结构化数据
        prompt = f"""
        从以下救援标准文档中提取装备清单：
        {text}

        输出格式（JSON）:
        ["生命探测仪", "破拆工具", "担架"]
        """
        # 调用GLM-4提取
        return ["生命探测仪", "破拆工具", "担架"]  # 简化示例

    async def _get_cultural_equipment(self, ethnicity: str) -> list:
        """获取文化装备"""
        cultural_map = {
            "藏族": ["藏语翻译设备", "糌粑", "酥油茶", "尊重天葬习俗培训材料"],
            "维吾尔族": ["维语翻译设备", "清真食品", "礼拜毯"],
            "回族": ["清真食品", "回族习俗手册"]
        }
        return cultural_map.get(ethnicity, [])
```

#### 推理过程可视化
```json
{
  "equipment_recommendation": {
    "basic": [
      "生命探测仪",
      "破拆工具",
      "担架",
      "发电机",
      "照明设备",
      "卫星电话"
    ],
    "special": [
      {
        "name": "防化服（A级）",
        "spec": "氯气防护，4小时续航",
        "reason": "灾区有化工厂生产氯气（剧毒），必须配备A级防化服"
      },
      {
        "name": "气体检测仪",
        "spec": "可检测氯气、氨气、硫化氢",
        "reason": "化工泄漏需要实时监测气体浓度"
      }
    ],
    "cultural": [
      "藏语翻译设备",
      "糌粑",
      "酥油茶",
      "尊重天葬习俗培训材料"
    ],
    "reasoning_chain": [
      {
        "step": "RAG检索",
        "source": "GB/T 33743-2017 地震应急救援指南",
        "result": "根据国标，需要生命探测仪、破拆工具、担架等基础装备"
      },
      {
        "step": "KG推理",
        "reasoning": "化工厂生产氯气（剧毒），需要防化服",
        "result": "防化服（A级）"
      },
      {
        "step": "案例匹配",
        "case": "雅安地震",
        "result": "雅安地震经验：增加卫星电话（山区通信保障）"
      },
      {
        "step": "人文分析",
        "ethnicity": "藏族",
        "result": "考虑藏族习俗，增加翻译设备、糌粑、酥油茶"
      }
    ]
  }
}
```

---

## 六、离线能力设计

### 6.1 离线数据存储

#### 车载服务器配置
```yaml
# 车载服务器硬件配置
Hardware:
  CPU: Intel i7-12700H (12核20线程)
  RAM: 32GB DDR5
  Storage: 2TB NVMe SSD
  GPU: NVIDIA RTX 4060 Laptop (8GB VRAM) # 本地推理
  Network:
    - 5G模块（主）
    - StarLink卫星（备）
    - 离线模式（无网络）

# 离线数据库
Offline_Databases:
  SQLite:
    path: /data/vehicle.db
    size: ~500MB
    content:
      - 基础装备清单
      - 重点目标数据
      - 历史案例摘要

  Embedded_Qdrant:
    path: /data/qdrant_offline/
    size: ~2GB
    content:
      - 压缩后的向量索引
      - Top 1000 常用文档

  Embedded_KG:
    path: /data/neo4j_offline/
    size: ~1GB
    content:
      - 核心推理规则
      - 常见化学品数据
      - 装备关系图谱
```

#### 数据同步机制
```python
# src/emergency_agents/offline/sync.py
import asyncio
from sqlalchemy import create_engine
from qdrant_client import QdrantClient

class OfflineDataSyncer:
    """离线数据同步（出发前/到达后）"""

    def __init__(self):
        self.remote_pg = create_engine(
            "postgresql://rescue:***@8.147.130.215:19532/rescue_system"
        )
        self.local_sqlite = create_engine("sqlite:////data/vehicle.db")

        self.remote_qdrant = QdrantClient(url="http://8.147.130.215:6333")
        self.local_qdrant = QdrantClient(path="/data/qdrant_offline")

    async def sync_before_departure(self, disaster_context: dict):
        """
        出发前同步（下载到车载服务器）

        同步内容:
        1. 灾区50km范围内的重点目标
        2. 灾区地理数据（道路、地形）
        3. 相关案例和装备手册
        4. 灾区人文数据（民族、宗教）
        """
        # 1. 同步重点目标
        await self._sync_priority_targets(disaster_context)

        # 2. 同步地理数据
        await self._sync_geographic_data(disaster_context)

        # 3. 同步RAG文档
        await self._sync_rag_documents(disaster_context)

        # 4. 同步KG子图
        await self._sync_kg_subgraph(disaster_context)

    async def _sync_priority_targets(self, disaster_context: dict):
        """同步重点目标（50km范围）"""
        # 从远程PostgreSQL查询
        query = """
        SELECT t.id, t.name, t.type, t.priority,
               ST_X(t.location) AS lon, ST_Y(t.location) AS lat,
               t.population, t.risk_level
        FROM priority_targets t
        WHERE ST_DWithin(
            t.location,
            ST_MakePoint($1, $2)::geography,
            50000  -- 50km
        )
        """
        results = self.remote_pg.execute(
            query,
            disaster_context['epicenter']
        )

        # 写入本地SQLite
        for row in results:
            self.local_sqlite.execute("""
                INSERT OR REPLACE INTO priority_targets
                (id, name, type, priority, lon, lat, population, risk_level)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, tuple(row))

    async def _sync_rag_documents(self, disaster_context: dict):
        """同步RAG文档（Top 1000最相关）"""
        # 查询灾区相关文档
        query_vector = self.embeddings.embed_query(
            f"{disaster_context['type']}救援 {disaster_context['location']}"
        )

        # 从远程Qdrant检索
        results = self.remote_qdrant.search(
            collection_name="rescue_standards",
            query_vector=query_vector,
            limit=1000  # 取Top 1000
        )

        # 写入本地Qdrant
        self.local_qdrant.upsert(
            collection_name="rescue_standards_offline",
            points=[
                {
                    "id": r.id,
                    "vector": r.vector,
                    "payload": r.payload
                }
                for r in results
            ]
        )

    async def sync_after_arrival(self):
        """
        到达后同步（上传到云端）

        上传内容:
        1. 现场照片/视频
        2. 任务进度更新
        3. 风险区域标注
        4. 审计日志
        """
        # 1. 上传媒体文件
        await self._upload_media_files()

        # 2. 上传进度报告
        await self._upload_progress_reports()

        # 3. 上传风险区域
        await self._upload_risk_zones()

        # 4. 上传审计日志
        await self._upload_audit_logs()
```

### 6.2 离线推理

#### 本地LLM部署（vLLM）
```bash
# 车载服务器启动vLLM服务
docker run -d --name vllm-glm4 \
  --gpus all \
  -p 8000:8000 \
  -v /data/models:/models \
  vllm/vllm-openai:latest \
  --model /models/glm-4-9b-chat \
  --served-model-name glm-4 \
  --max-model-len 8192 \
  --gpu-memory-utilization 0.9

# 配置环境变量（离线模式）
export OPENAI_BASE_URL=http://localhost:8000/v1
export OPENAI_API_KEY=offline-mode
```

#### 离线RAG检索
```python
# src/emergency_agents/offline/rag.py
from qdrant_client import QdrantClient

class OfflineRAG:
    """离线RAG检索（使用本地数据）"""

    def __init__(self):
        # 使用本地Qdrant
        self.qdrant = QdrantClient(path="/data/qdrant_offline")

        # 使用本地嵌入模型（ONNX Runtime）
        from optimum.onnxruntime import ORTModelForFeatureExtraction
        self.embeddings = ORTModelForFeatureExtraction.from_pretrained(
            "/data/models/bge-m3-onnx",
            provider="CUDAExecutionProvider"  # GPU加速
        )

    async def retrieve_offline(self, query: str, top_k: int = 5):
        """离线检索（无需网络）"""
        # 本地嵌入
        query_vector = self.embeddings.encode(query)

        # 本地向量检索
        results = self.qdrant.search(
            collection_name="rescue_standards_offline",
            query_vector=query_vector,
            limit=top_k
        )

        return [
            {
                "text": r.payload["text"],
                "source": r.payload["source"],
                "score": r.score
            }
            for r in results
        ]
```

### 6.3 离线/在线自动切换

```python
# src/emergency_agents/offline/adaptive.py
import httpx
from tenacity import retry, stop_after_attempt, wait_fixed

class AdaptiveService:
    """自适应服务（自动切换离线/在线）"""

    def __init__(self):
        self.online = self._check_network()
        self.fallback_to_offline = False

    def _check_network(self) -> bool:
        """检查网络连接"""
        try:
            response = httpx.get(
                "http://8.147.130.215:6333/health",
                timeout=3.0
            )
            return response.status_code == 200
        except:
            return False

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(1))
    async def retrieve(self, query: str, top_k: int = 5):
        """
        自适应检索（优先在线，失败自动切换离线）
        """
        if self.online and not self.fallback_to_offline:
            try:
                # 尝试在线检索
                return await self._retrieve_online(query, top_k)
            except Exception as e:
                # 在线失败，切换离线
                print(f"在线检索失败: {e}，切换离线模式")
                self.fallback_to_offline = True
                return await self._retrieve_offline(query, top_k)
        else:
            # 直接离线检索
            return await self._retrieve_offline(query, top_k)

    async def _retrieve_online(self, query: str, top_k: int):
        """在线检索（远程Qdrant）"""
        qdrant = QdrantClient(url="http://8.147.130.215:6333")
        # ...检索逻辑

    async def _retrieve_offline(self, query: str, top_k: int):
        """离线检索（本地Qdrant）"""
        qdrant = QdrantClient(path="/data/qdrant_offline")
        # ...检索逻辑
```

---

## 七、三阶段系统集成

### 7.1 阶段切换机制

```python
# src/emergency_agents/api/stage_controller.py
from fastapi import APIRouter
from enum import Enum

class Stage(str, Enum):
    PLANNING = "planning"      # 阶段1: 出发前规划
    MONITORING = "monitoring"   # 阶段2: 行进中监控
    COMMANDING = "commanding"   # 阶段3: 现场指挥

router = APIRouter(prefix="/api/v1/stage", tags=["阶段管理"])

@router.post("/switch")
async def switch_stage(request: StageSwitchRequest):
    """
    阶段切换

    触发条件:
    - PLANNING → MONITORING: 指挥员审批通过
    - MONITORING → COMMANDING: 车队到达现场（GPS判定）
    """
    current_stage = request.current_stage
    target_stage = request.target_stage

    # 验证切换合法性
    if current_stage == Stage.PLANNING and target_stage == Stage.MONITORING:
        # 检查是否已审批
        if not await check_approval(request.convoy_id):
            return {"error": "未审批，无法出发"}

        # 启动行进中监控
        await start_monitoring(request.convoy_id)

    elif current_stage == Stage.MONITORING and target_stage == Stage.COMMANDING:
        # 检查是否已到达
        if not await check_arrival(request.convoy_id):
            return {"error": "未到达，无法开始指挥"}

        # 启动现场指挥
        await start_commanding(request.convoy_id)

    else:
        return {"error": "非法阶段切换"}

    return {
        "status": "success",
        "from_stage": current_stage,
        "to_stage": target_stage,
        "switched_at": datetime.now()
    }

async def check_arrival(convoy_id: str) -> bool:
    """判断是否到达（GPS距离 < 1km）"""
    convoy = await get_convoy(convoy_id)
    current_location = convoy["current_location"]
    destination = convoy["destination"]

    distance_km = calculate_distance(current_location, destination)

    return distance_km < 1.0  # 小于1km视为到达
```

### 7.2 数据流转设计

```
阶段1: 出发前规划（县应急中心）
   ↓
[规划数据] → PostgreSQL持久化
   ├── disaster_assessment
   ├── equipment_recommendation
   ├── route_plan
   └── priority_targets
   ↓
[同步] → 车载SQLite（离线数据）
   ↓

阶段2: 行进中监控（车载指挥车）
   ↓
[实时数据] → Redis缓存（1秒更新）
   ├── vehicle_positions (WebSocket推送)
   ├── danger_alerts
   └── road_conditions
   ↓
[持久化] → PostgreSQL（每分钟一次）
   ↓

阶段3: 现场指挥（前线指挥部）
   ↓
[任务数据] → PostgreSQL + Redis
   ├── task_assignments
   ├── rescuer_status
   └── progress_reports (救援队APP上报)
   ↓
[上报] → 省级系统API
   ├── disaster_summary
   ├── resource_needs
   └── media_attachments
```

### 7.3 界面适配

#### 阶段1: 墙面大屏（1920x1080）
```typescript
// src/pages/planning/PlanningDashboard.tsx
import { Card, Row, Col, Button } from 'antd';
import { MapContainer } from '@/components/MapContainer';
import { EquipmentRecommendation } from '@/components/EquipmentRecommendation';

export const PlanningDashboard = () => {
  return (
    <div className="planning-dashboard" style={{ height: '100vh' }}>
      <Row gutter={16} style={{ height: '100%' }}>
        {/* 左侧: 地图（60%） */}
        <Col span={14} style={{ height: '100%' }}>
          <Card title="灾区地图与路线规划" style={{ height: '100%' }}>
            <MapContainer
              center={disaster.epicenter}
              zoom={10}
              layers={[
                'earthquake-intensity',  // 地震烈度
                'priority-targets',      // 重点目标
                'route-primary',         // 主路线
                'route-backup',          // 备用路线
                'risk-zones'             // 风险区域
              ]}
            />
          </Card>
        </Col>

        {/* 右侧: 信息面板（40%） */}
        <Col span={10} style={{ height: '100%' }}>
          <Card title="灾情评估" style={{ marginBottom: 16 }}>
            <DisasterAssessment data={assessment} />
          </Card>

          <Card title="装备推荐" style={{ marginBottom: 16 }}>
            <EquipmentRecommendation
              basic={equipment.basic}
              special={equipment.special}
              cultural={equipment.cultural}
              reasoningChain={equipment.reasoning_chain}
            />
          </Card>

          <Card title="重点目标识别">
            <PriorityTargets targets={targets} />
          </Card>

          {/* 审批按钮（指挥员） */}
          <Button
            type="primary"
            size="large"
            block
            style={{ marginTop: 16, height: 60, fontSize: 20 }}
            onClick={handleApproval}
          >
            审批通过，立即出发
          </Button>
        </Col>
      </Row>
    </div>
  );
};
```

#### 阶段2: 车载中控屏（特殊优化）
```typescript
// src/pages/monitoring/VehicleDashboard.tsx
import { Alert, Card } from 'antd';
import { DangerLevelIndicator } from '@/components/DangerLevelIndicator';

export const VehicleDashboard = () => {
  const dangerLevel = useDangerLevel();  // L0/L1/L2/L3

  return (
    <div className="vehicle-dashboard" style={{
      height: '100vh',
      fontSize: '24px',  // 大字体（车载震动）
      backgroundColor: '#000'  // 黑色背景（减少反光）
    }}>
      {/* 顶部: 危险预警（全宽） */}
      {dangerLevel !== 'L0' && (
        <Alert
          type={dangerLevel === 'L3' ? 'error' : 'warning'}
          message={getDangerMessage(dangerLevel)}
          banner
          style={{
            fontSize: 32,
            fontWeight: 'bold',
            animation: dangerLevel === 'L3' ? 'blink 1s infinite' : 'none'
          }}
        />
      )}

      {/* 中部: 地图（前方路况） */}
      <div style={{ height: '60%', padding: 20 }}>
        <MapContainer
          center={convoy.current_location}
          zoom={13}
          pitch={60}  // 3D倾斜视角
          bearing={convoy.heading}  // 前进方向
          layers={[
            'route-ahead',      // 前方路线
            'danger-zones',     // 危险区域
            'drone-view'        // 无人机实时画面
          ]}
        />
      </div>

      {/* 底部: 车队信息 */}
      <div style={{ height: '40%', padding: 20 }}>
        <Row gutter={16}>
          <Col span={12}>
            <Card title="车队状态">
              <ConvoyStatus vehicles={convoy.vehicles} />
            </Card>
          </Col>
          <Col span={12}>
            <Card title="前方路况">
              <RoadCondition data={roadCondition} />
            </Card>
          </Col>
        </Row>
      </div>

      {/* 语音提示（自动播放） */}
      <AudioAlert level={dangerLevel} />
    </div>
  );
};
```

#### 阶段3: 救援队APP（React Native）
```typescript
// mobile-app/src/screens/TaskScreen.tsx
import React from 'react';
import { View, Text, Button, FlatList } from 'react-native';
import { useTaskList } from '@/hooks/useTaskList';

export const TaskScreen = () => {
  const { tasks, updateProgress } = useTaskList();

  return (
    <View style={{ flex: 1, padding: 16 }}>
      <Text style={{ fontSize: 24, fontWeight: 'bold', marginBottom: 16 }}>
        我的任务
      </Text>

      <FlatList
        data={tasks}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TaskCard
            task={item}
            onProgressUpdate={(progress) => updateProgress(item.id, progress)}
          />
        )}
      />
    </View>
  );
};

const TaskCard = ({ task, onProgressUpdate }) => {
  return (
    <View style={{
      backgroundColor: '#fff',
      padding: 16,
      marginBottom: 12,
      borderRadius: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3
    }}>
      <Text style={{ fontSize: 18, fontWeight: 'bold' }}>
        {task.title}
      </Text>
      <Text style={{ color: '#666', marginTop: 4 }}>
        {task.description}
      </Text>

      {/* 进度条 */}
      <ProgressBar
        progress={task.progress_percent}
        style={{ marginTop: 12 }}
      />

      {/* 上报按钮 */}
      <Button
        title="上报进度"
        onPress={() => {
          // 打开进度上报表单
          navigation.navigate('ProgressReport', { taskId: task.id });
        }}
        style={{ marginTop: 12 }}
      />
    </View>
  );
};
```

---

## 八、部署架构

### 8.1 云端部署（县应急中心）

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Nginx反向代理
  nginx:
    image: nginx:1.25-alpine
    ports:
      - "443:443"
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend

  # FastAPI后端（3副本）
  backend:
    image: rescue-api:latest
    deploy:
      replicas: 3
    environment:
      - POSTGRES_DSN=postgresql://rescue:***@postgres:5432/rescue_system
      - NEO4J_URI=bolt://neo4j:7687
      - QDRANT_URL=http://qdrant:6333
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - neo4j
      - qdrant
      - redis

  # PostgreSQL数据库
  postgres:
    image: postgis/postgis:15-3.4-alpine
    environment:
      POSTGRES_USER: rescue
      POSTGRES_PASSWORD: rescue_password
      POSTGRES_DB: rescue_system
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Neo4j知识图谱
  neo4j:
    image: neo4j:5.0-enterprise
    environment:
      NEO4J_AUTH: neo4j/example-neo4j
    volumes:
      - neo4j_data:/data

  # Qdrant向量数据库
  qdrant:
    image: qdrant/qdrant:v1.7.4
    volumes:
      - qdrant_data:/qdrant/storage

  # Redis缓存
  redis:
    image: redis:7.2-alpine
    volumes:
      - redis_data:/data

  # vLLM推理服务（GPU节点）
  vllm:
    image: vllm/vllm-openai:latest
    runtime: nvidia
    environment:
      - MODEL_NAME=THUDM/glm-4-9b-chat
    volumes:
      - ./models:/models

volumes:
  postgres_data:
  neo4j_data:
  qdrant_data:
  redis_data:
```

### 8.2 车载部署（边缘计算）

```yaml
# 车载服务器部署架构
Vehicle_Server:
  Hardware:
    - Intel i7-12700H (12核20线程)
    - 32GB DDR5
    - 2TB NVMe SSD
    - NVIDIA RTX 4060 Laptop (8GB VRAM)

  Software:
    OS: Ubuntu 22.04 LTS
    Container: Docker + Docker Compose
    Runtime: NVIDIA Container Toolkit

  Services:
    # 1. 本地API服务
    - fastapi_local:
        image: rescue-api:edge
        replicas: 1
        resources:
          cpu: 4 cores
          memory: 8GB

    # 2. 本地vLLM服务（离线推理）
    - vllm_local:
        image: vllm/vllm-openai:latest
        model: glm-4-9b-chat-int8  # INT8量化
        gpu_memory: 6GB

    # 3. 本地SQLite数据库
    - sqlite:
        path: /data/vehicle.db
        size: 500MB

    # 4. 本地Qdrant（嵌入式模式）
    - qdrant_embedded:
        path: /data/qdrant_offline
        size: 2GB

    # 5. 同步服务（离线/在线切换）
    - sync_service:
        schedule: "*/5 * * * *"  # 每5分钟检查网络
        actions:
          - check_network
          - upload_progress
          - download_updates

  Network:
    Primary: 5G Module (中国移动)
    Backup: StarLink卫星
    Offline: Local-only mode

  Monitoring:
    - Prometheus (资源监控)
    - Grafana (可视化仪表盘)
    - AlertManager (告警通知)
```

### 8.3 省级对接

```python
# src/emergency_agents/integration/provincial_api.py
import httpx
from tenacity import retry, stop_after_attempt

class ProvincialAPIClient:
    """省级指挥大厅API对接"""

    def __init__(self):
        self.base_url = "https://provincial-command.example.com/api/v1"
        self.api_key = os.getenv("PROVINCIAL_API_KEY")

    @retry(stop=stop_after_attempt(3))
    async def submit_report(
        self,
        report_id: str,
        content: dict,
        attachments: list
    ):
        """
        向省级提交灾情报告

        数据格式:
        {
            "disaster_id": "disaster_20250127_001",
            "county": "余杭区",
            "commander": "王指挥员",
            "summary": {
                "casualties": {"dead": 10, "injured": 50},
                "affected_population": 50000,
                "collapsed_buildings": 120
            },
            "rescue_progress": {
                "tasks_total": 50,
                "tasks_completed": 12,
                "rescuers_deployed": 200
            },
            "resource_needs": {
                "medical_supplies": "急需血浆200袋",
                "equipment": "需要大型吊车2台",
                "personnel": "需要医疗队50人"
            },
            "attachments": [
                {"type": "photo", "url": "https://..."},
                {"type": "video", "url": "https://..."}
            ]
        }
        """
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/reports",
                json={
                    "report_id": report_id,
                    "content": content,
                    "attachments": attachments
                },
                headers={
                    "X-API-Key": self.api_key,
                    "X-County": "yuhang",
                    "X-Request-ID": str(uuid.uuid4())
                },
                timeout=30.0
            )

            if response.status_code == 200:
                return {
                    "status": "success",
                    "provincial_report_id": response.json()["report_id"]
                }
            else:
                raise Exception(f"省级API调用失败: {response.text}")

    @retry(stop=stop_after_attempt(3))
    async def request_support(
        self,
        disaster_id: str,
        support_type: str,
        details: dict
    ):
        """
        向省级请求支援

        支援类型:
        - personnel: 人员支援（如医疗队、特种部队）
        - equipment: 装备支援（如大型机械、通信设备）
        - supplies: 物资支援（如帐篷、食品、药品）
        """
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/support-requests",
                json={
                    "disaster_id": disaster_id,
                    "county": "yuhang",
                    "support_type": support_type,
                    "details": details,
                    "urgency": details.get("urgency", "high")
                },
                headers={
                    "X-API-Key": self.api_key
                },
                timeout=30.0
            )

            return response.json()
```

---

## 九、性能指标

### 9.1 响应时间要求

| 接口 | P50 | P95 | P99 | 超时阈值 |
|------|-----|-----|-----|---------|
| 健康检查 | 10ms | 50ms | 100ms | 200ms |
| 灾情评估 | 500ms | 2s | 5s | 10s |
| 装备推荐 | 1s | 3s | 8s | 15s |
| 路线规划 | 2s | 5s | 10s | 20s |
| 危险预测 | 200ms | 500ms | 1s | 2s |
| 任务分配 | 1s | 3s | 6s | 10s |
| 进度上报 | 100ms | 300ms | 500ms | 1s |

### 9.2 吞吐量要求

| 场景 | 并发用户 | TPS | QPS |
|------|---------|-----|-----|
| 县应急中心 | 10人 | 100 | 500 |
| 车载系统 | 5人 | 50 | 200 |
| 救援队APP | 200人 | 500 | 2000 |

### 9.3 资源消耗

```yaml
# 云端部署资源
Cloud_Resources:
  Backend_Pods: 3 replicas
    CPU: 2 cores each
    Memory: 4GB each

  PostgreSQL:
    CPU: 4 cores
    Memory: 16GB
    Storage: 500GB SSD

  Neo4j:
    CPU: 4 cores
    Memory: 16GB
    Storage: 200GB SSD

  Qdrant:
    CPU: 2 cores
    Memory: 8GB
    Storage: 100GB SSD

  vLLM:
    GPU: 1x NVIDIA A100 (80GB)
    CPU: 8 cores
    Memory: 32GB

# 车载部署资源
Vehicle_Resources:
  Total: Intel i7-12700H + 32GB RAM + RTX 4060

  FastAPI: 4 cores + 8GB
  vLLM: 4 cores + 8GB + 6GB VRAM
  Databases: 2 cores + 8GB
  Monitoring: 2 cores + 4GB
```

---

## 十、安全设计

### 10.1 认证鉴权

```python
# src/emergency_agents/auth/rbac.py
from enum import Enum

class Role(str, Enum):
    """角色定义（RBAC）"""
    COMMANDER = "commander"       # 指挥员：全部权限
    COORDINATOR = "coordinator"   # 协调员：只能协调，不能直接指挥
    RESCUER = "rescuer"          # 救援队员：只能上报进度
    VIEWER = "viewer"            # 观察员：只读权限

# 权限矩阵
PERMISSIONS = {
    Role.COMMANDER: [
        "planning:*",        # 出发前规划全部权限
        "monitoring:*",      # 行进中监控全部权限
        "commanding:*",      # 现场指挥全部权限
        "approval:approve",  # 审批权限
    ],
    Role.COORDINATOR: [
        "commanding:coordinate",  # 只能协调
        "progress:view",          # 查看进度
    ],
    Role.RESCUER: [
        "task:view",              # 查看任务
        "progress:report",        # 上报进度
        "resource:request",       # 申请资源
    ],
    Role.VIEWER: [
        "*:view",                 # 全部只读
    ]
}

def check_permission(user_role: Role, action: str) -> bool:
    """检查权限"""
    user_permissions = PERMISSIONS[user_role]

    # 通配符匹配
    for perm in user_permissions:
        if perm == "*" or perm == action:
            return True
        if perm.endswith(":*") and action.startswith(perm[:-1]):
            return True

    return False
```

### 10.2 数据加密

```yaml
# 传输加密
Transport:
  - HTTPS (TLS 1.3)
  - WebSocket over TLS (wss://)
  - 证书: Let's Encrypt自动续期

# 存储加密
Storage:
  PostgreSQL:
    - 数据库级加密（pgcrypto扩展）
    - 敏感字段加密（AES-256-GCM）

  Neo4j:
    - 磁盘加密（LUKS）

  Qdrant:
    - 磁盘加密（LUKS）

  车载SQLite:
    - SQLCipher加密（AES-256-CBC）

# API密钥管理
API_Keys:
  Storage: HashiCorp Vault
  Rotation: 每90天自动轮换
  Scopes: 最小权限原则
```

### 10.3 审计日志

```python
# src/emergency_agents/audit/logger.py
from sqlalchemy import create_engine, Column, String, JSONB, TIMESTAMP
from sqlalchemy.dialects.postgresql import UUID
import uuid
from datetime import datetime

class AuditLog:
    """审计日志（关键操作全记录）"""

    def __init__(self):
        self.engine = create_engine(
            "postgresql://rescue:***@8.147.130.215:19532/rescue_system"
        )

    async def log_action(
        self,
        user_id: str,
        action: str,
        resource_type: str,
        resource_id: str,
        changes: dict,
        ip_address: str,
        user_agent: str
    ):
        """
        记录关键操作

        典型场景:
        - 指挥员审批救援方案
        - 分配任务给救援队员
        - 修改重点目标优先级
        - 上报灾情到省级
        """
        await self.engine.execute("""
            INSERT INTO audit_logs
            (id, user_id, action, resource_type, resource_id,
             changes, ip_address, user_agent, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        """,
            str(uuid.uuid4()),
            user_id,
            action,
            resource_type,
            resource_id,
            changes,  # JSONB: {"before": {...}, "after": {...}}
            ip_address,
            user_agent,
            datetime.now()
        )

    async def query_user_actions(
        self,
        user_id: str,
        start_date: datetime,
        end_date: datetime
    ):
        """查询用户操作历史（决策回溯）"""
        results = await self.engine.execute("""
            SELECT action, resource_type, resource_id, changes, created_at
            FROM audit_logs
            WHERE user_id = $1
              AND created_at >= $2
              AND created_at <= $3
            ORDER BY created_at DESC
        """, user_id, start_date, end_date)

        return [dict(row) for row in results]
```

---

## 十一、附录

### 11.1 术语表

| 术语 | 英文 | 说明 |
|------|------|------|
| 车载移动指挥系统 | Vehicle-Mounted Command System | 县级应急救援车载平台 |
| 三阶段运行 | Three-Stage Operation | 出发前/行进中/现场 |
| 离线优先 | Offline-First | 断网情况下核心功能可用 |
| RAG | Retrieval Augmented Generation | 检索增强生成 |
| KG | Knowledge Graph | 知识图谱 |
| LangGraph | - | 状态机编排框架 |
| 危险分级 | Danger Classification | L0-L3四级预警 |
| 三层指挥 | Three-Tier Command | 直接指挥/协调/信息上报 |
| 重点目标 | Priority Target | P0-P2优先级目标 |

### 11.2 参考资料

- **国家标准**:
  - GB/T 33743-2017 地震应急救援指南
  - GB 18218-2018 危险化学品重大危险源辨识

- **技术文档**:
  - LangGraph Documentation: https://langchain-ai.github.io/langgraph/
  - Qdrant Documentation: https://qdrant.tech/documentation/
  - Neo4j Cypher Manual: https://neo4j.com/docs/cypher-manual/

- **历史案例**:
  - 汶川地震救援总结（2008）
  - 雅安地震救援经验（2013）
  - 九寨沟地震应急响应分析（2017）

### 11.3 版本历史

| 版本 | 日期 | 变更内容 |
|------|------|---------|
| v1.0 | 2025-10-27 | 初始版本，完整技术架构设计 |

---

**文档结束**

> **下一步**: 根据本技术架构文档，开始Sprint 1（第1周）的开发工作。

