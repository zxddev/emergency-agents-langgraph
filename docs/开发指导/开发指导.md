# 开发指导（Sequential Thinking）

> 目标：以“先易后难、先骨架后细节”的顺序，快速跑通到可验收的最小闭环（Phase‑A）。

---

## 总览（顺序思考）
1) 底座通：数据库/向量/图库/监控 → “能连、能存、能看”。
2) 编排通：LangGraph（PostgresSaver + interrupt + 回放）→ “能中断、能恢复”。
3) 记忆通：Mem0（user/run 过滤 + 图记忆）→ “能写、能查、可审计”。
4) 检索通：LlamaIndex→Qdrant → “能检索可引用片段”。
5) 接口通：装备推荐/案例检索 → “能给出答案 + 证据链”。
6) 观测通：/metrics + Trace → “能看TTFT/TBT/错误率、能追踪”。

---

## 步骤与验收（DoD）

### 1. 底座通
- 步骤：
  - Qdrant/Grafana/Prometheus 启动（在服务器 `/opt/ai-emergency/infra` 已提供 compose）。
  - 本地配置 `config/dev.env` 指向服务器（Qdrant/Neo4j/Postgres）。
- DoD：
  - `curl http://<srv>:6333` 有响应；Neo4j Browser 可登录；`psql` 可连接。

### 2. 编排通
- 步骤：
  - 将 Checkpointer 切为 PostgresSaver；节点加入 `interrupt` 审批示例；错误路由与幂等示例。
  - 本地启动 API：`uvicorn emergency_agents.api.main:app --reload --port 8008`。
- DoD：
  - `POST /threads/start?rescue_id=demo` 能运行；`/threads/resume?rescue_id=demo` 能从中断续跑；能导出回放数据。

### 3. 记忆通
- 步骤：
  - 接入 Mem0：`add/search` 强制 `user_id`、推荐 `run_id`；开启 Graph Memory → Neo4j；写入审计（hash/actor/rescue_id）。
- DoD：
  - 写入3条会话记忆；`search` 返回实体/关系；Neo4j 中可见新增节点/关系。

### 4. 检索通
- 步骤：
  - LlamaIndex 建4域索引（规范/案例/地理/装备）→ Qdrant；与 Mem0 共用 `EMBEDDING_MODEL/EMBEDDING_DIM`；索引阶段校验维度。
- DoD：
  - 检索返回可引用片段（文本+来源）。

### 5. 接口通
- 步骤：
  - 新增接口：`/recommend/equipment`、`/cases/search`；按 KG→RAG→合成 返回答案与证据。
- DoD：
  - 装备推荐返回匹配理由（能力覆盖/规则链）；案例检索返回子图/片段与引用。

### 6. 观测通
- 步骤：
  - API 接入 /metrics 与 OTEL Trace；Prometheus 添加 scrape；Grafana 导入面板。
- DoD：
  - 看板可见 TTFT/TBT/错误率/队列长度；Trace 可串起关键节点。

---

## 环境要求
- Python >= 3.10
- 依赖版本见 `requirements.txt`（LangGraph >= 0.2.0, LlamaIndex >= 0.10.0, Mem0 最新版）
- 服务器资源地址需在 `config/dev.env` 中配置（`QDRANT_URL/NEO4J_URI/POSTGRES_DSN`）

---

## 命令速查

```bash
# 1) 安装依赖
pip install -r requirements.txt

# 2) 启动本地 API
python -m uvicorn emergency_agents.api.main:app --reload --port 8008

# 3) 验证编排
curl -X POST "http://localhost:8008/threads/start?rescue_id=rescue_demo_001"
curl -X POST "http://localhost:8008/threads/resume?rescue_id=rescue_demo_001"

# 4) 服务器侧（已部署）
# /opt/ai-emergency/infra 下：
docker compose up -d
```

---

## 配置说明（节选）
- `OPENAI_BASE_URL/OPENAI_API_KEY/LLM_MODEL`：智谱或 vLLM，后续仅改配置。
- `EMBEDDING_MODEL/EMBEDDING_DIM`：RAG 与 Mem0 共用，索引阶段校验。
- `POSTGRES_DSN/QDRANT_URL/NEO4J_URI`：生产环境指向服务器资源。
  - 本地开发：推荐 PostgreSQL（支持并发、回放）；SQLite 仅限快速原型验证（不支持并发）。
  - 示例：`QDRANT_URL=http://<服务器IP>:6333`，`NEO4J_URI=bolt://<服务器IP>:7687`

---

## 里程碑（按优先级）
- **P0（必须）**
  - M1：编排通（中断/恢复/回放）
  - M2：记忆通（Graph Memory 入 Neo4j）
- **P1（重要）**
  - M3：检索通（四域可引用片段）
  - M4：接口通（推荐/案例检索）
- **P2（增强）**
  - M5：观测通（SLO 看板 + Trace）

---

## 注意事项
- 先规则后生成：闸门/禁令类用规则与图，生成只做解释。
- 幂等优先：节点重复执行不应产生副作用。
- 审计与版本：所有写入与关键动作必须可追溯。

---

## 常见问题排查

### 1. Qdrant 连接失败
```bash
# 检查端口是否开放
curl http://<服务器IP>:6333/collections
# 防火墙放行：sudo ufw allow 6333
```

### 2. PostgresSaver 报错 "relation does not exist"
```python
# 首次使用需初始化表结构
from langgraph.checkpoint.postgres import PostgresSaver
with pool.connection() as conn:
    saver = PostgresSaver(conn)
    saver.setup()  # 创建 checkpoints 表
```

### 3. Neo4j 连接超时
```bash
# 检查 Bolt 协议端口
telnet <服务器IP> 7687
# 确认 Neo4j 配置允许远程连接：
# dbms.default_listen_address=0.0.0.0
```

### 4. 嵌入维度不匹配
```python
# 确保 RAG 与 Mem0 使用同一配置
EMBEDDING_MODEL = "text-embedding-3-small"  # 或其他模型
EMBEDDING_DIM = 1536  # 必须与模型输出维度一致
# 索引时校验：assert embedding.shape[-1] == EMBEDDING_DIM
```
