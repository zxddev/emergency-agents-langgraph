# 救援场景推送链路（AI → Java → 前端地图）

## 1. AI 触发端

- **救援任务意图**：LangGraph 在 `ws_notify` 节点内判断是否需要推送场景，成功匹配救援资源后调用编排服务。  
  `src/emergency_agents/intent/handlers/rescue_task_generation.py:640-699`  
  - 无事件时先调用 `_build_incident_payload` 创建事件，再记录 `incident_id`。  
  - 构造 `RescueScenarioPayload`（位置、标题、内容、scope=commander 等）并调用 `orchestrator.publish_rescue_scenario(...)`。  
  - 日志点：`rescue_scenario_publish_attempt`、`rescue_scenario_publish_success`，失败时输出 `rescue_scenario_publish_failed`。

- **方案生成智能体**：流程图阶段完成后同样复用 `_push_to_orchestrator`，确保审批前也能向 Java 推送建议。  
  `src/emergency_agents/agents/plan_generator.py:250-386`

- **HTTP 客户端封装**：`OrchestratorClient.publish_rescue_scenario` 将数据 POST 至 `/api/v1/rescue/scenario`，写入标准日志用于排障。  
  `src/emergency_agents/external/orchestrator_client.py:55-113`

- **REST 自测入口**：
  - `POST /intent/process`（FastAPI）：直接走 `process_intent_core`，写入会话/消息并返回意图、证据与历史。  
    ```bash
    curl -s -X POST "http://127.0.0.1:8008/intent/process" \
         -H 'Content-Type: application/json' \
         -d '{
               "user_id": "commander-demo",
               "thread_id": "demo-thread-001",
               "message": "汶川南新村10人被困，需要破拆支撑设备。",
               "metadata": {"incident_id": "fef8469f-5f78-4dd4-8825-dbc915d1b630"}
             }' | jq '.status,.intent.intent_type'
    ```
  - `POST /conversations/history`：校验线程归属后返回完整消息列表，便于人工核对 `pending_entities`、证据等：
    ```bash
    curl -s -X POST "http://127.0.0.1:8008/conversations/history" \
         -H 'Content-Type: application/json' \
         -d '{"user_id":"commander-demo","thread_id":"demo-thread-001","limit":20}' | jq '.total'
    ```
  - 关键日志：`rest_intent_processed`（成功）、`conversation_history_fetched`（查询历史），异常时关注 `conversation_not_found` / `thread_ownership_mismatch`。
  - 默认事件兜底：当前端未携带 `incident_id` 时，`process_intent_core` 会自动补齐 `fef8469f-5f78-4dd4-8825-dbc915d1b630`，日志关键字 `intent_using_default_incident`（位置：`src/emergency_agents/api/intent_processor.py:150-172`）。入口日志 `intent_processing_start` 会记录线程、用户与预览文本，便于排查链路起点。

## 2. Java Web-API 中转层

- **Controller**：`RescueScenarioController.publish` 接收 AI 请求。  
  `emergency-web-api/src/main/java/com/cykj/webapi/rescue/scenario/RescueScenarioController.java:18-27`

- **Service 聚合**：`RescueScenarioService.publish` 查询事件详情、拼装 `TaskScenarioRequest`，并调用场景服务广播。  
  `emergency-web-api/src/main/java/com/cykj/webapi/rescue/scenario/RescueScenarioService.java:31-112`  
  - `extra` 中固定 `module=event`、`module_next=1-1`，附带坐标、hazards、能力标签等。  
  - `buildScenarioEntities` 会把事件绑定的实体信息转成 `entityIds`。

- **场景广播**：`EventScenarioService.triggerTaskScenario2` -> `publishScenarioMessage`。  
  `emergency-web-api/src/main/java/com/cykj/webapi/debug/service/EventScenarioService.java:1502-1541,2299-2333`  
  - 主题：`/topic/scenario.task.triggered`（`ScenarioCategory.TASK`）。  
  - 负载字段：`title/content/scope/isPop/entityIds/extra/messageId`。  
  - 若 `isPop=true`，还会写入 `MessageCache` 供弹窗重放。

## 3. 前端 WebSocket 消费

- **STOMP 客户端**：`EntityWebSocketClient` 订阅前述主题，并在 `handleMessage` 中派发 `scenario.task`.  
  `emergency-rescue-brain/src/services/map/EntityWebSocketClient.js:1-200`

- **场景处理入口**：`ai-broadcast.jsx` 的 `onScenarioEvent` 针对 `scenarioType === 'task'` 先校验角色，再：  
  `emergency-rescue-brain/src/view/ai/ai-broadcast.jsx:266-318`  
  - 调用 `emitScenarioMessage` 弹窗 / 播报；  
  - 触发 `ACTION_EVENTS.REFRESH_MODULE` 以刷新面板；  
  - 调用 `handleEntityList(entityIds)` 获取地图实体。

## 4. 实体拉取与地图动画

- **实体接口**：前端通过 `/api/v1/entities/by-ids` 精确拉取场景实体。  
  `emergency-rescue-brain/src/api/entities.js:71-84`  
  `emergency-web-api/src/main/java/com/cykj/webapi/entity/EntityController.java:156-175`

- **地图事件映射**：`handleEntity.js` 根据实体 `type` 转成 `MAP_EVENTS`，驱动 Mars3D 图层渲染（点、路线、区域等）。  
  `emergency-rescue-brain/src/components/map/handleEntity.js:1-160`

- **地图监听**：`MainMap` / `EntityLayerManager` 订阅 `MAP_EVENTS` 并执行具体动画（文件未展开，保持既有实现）。

## 5. 关键日志链

| 环节 | 日志关键字 |
| --- | --- |
| LangGraph 推送 | `rescue_scenario_publish_attempt` / `rescue_scenario_publish_success`（或 failed） |
| Orchestrator HTTP | `orchestrator_http_post` / `orchestrator_http_success` |
| Java 场景广播 | `rescue_scenario_publish_start` / `rescue_scenario_published` / `Broadcasting scenario message` |
| 前端订阅 | 浏览器控制台 `EntityWS` 调试或 `console.log(data)`（`ai-broadcast.jsx`） |

## 6. 调试手册

1. **AI 侧回溯**：检查 LangGraph 日志确认事件与场景 payload 是否生成。  
2. **接口连通性**：`curl http://<web-api>/web-api/api/v1/rescue/scenario` 验证 Java 接收；若 4xx/5xx，对应 `rescue_scenario_publish_failed`。  
3. **STOMP 主题**：使用 `@stomp/stompjs` 临时脚本订阅 `/topic/scenario.task.triggered` 检查实时消息。  
4. **实体查询**：确认 `/api/v1/entities/by-ids` 返回数据与 `entityIds` 对齐，否则地图不会渲染。  
5. **角色权限**：前端仅在 `scope` 包含当前角色时处理动画，如 commander/scout 需对应登录角色。

> 以上链路覆盖从 AI 输出到前端动画的全部必经节点，可作为后续定位救援动画异常的基线参考。
