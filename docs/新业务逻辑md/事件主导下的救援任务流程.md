# 事件主导下的救援任务流程

## 背景
早期 LangGraph 设计为“AI 发现线索即创建新事件”，Java/前端尚未成型时仍可运行。但现在：
- Java Web-API 已通过 `operational.events` 管理事件全生命周期，`EventServiceImpl` 负责创建/更新/广播。
- 前端所有地图实体、弹窗、任务面板等，都围绕既有事件 ID 进行展示与控制。
- Orchestrator 推送 `/topic/scenario.task.triggered`、`/topic/scenario.disaster.triggered` 等消息时，同样依赖事件上下文。

若 AI 仍“每次自建 incident”，会造成同名但不同 ID 的事件并存，任务、态势、审批都无法汇聚到真实事件流程里。

## 推荐流程
```
人工/外部系统创建事件 → AI 绑定事件上下文 → 生成任务方案 → 发布/审批 → 执行 & 记录
```
要点：
1. **事件创建**：`/web-api/api/incidents` 由指挥人员或外部系统调用，确定标题、类型（11 个枚举）、级别等。WebSocket 对应事件视图已上线。
2. **会话绑定**：调用 LangGraph 时，将正在处理的 `incident_id` 填入 `conversation_context`（例如 `/threads/start` 的请求体或后续上下文命令）。若未传入，系统会 fallback 到演示事件 `fef8469f-5f78-4dd4-8825-dbc915d1b630`。
3. **任务生成**：`RescueTaskGenerationHandler` 应直接复用 `incident_id`，跳过 `create_incident`，仅调用 `publish_rescue_scenario` 推送建议/任务。
4. **审批与执行**：LangGraph 在 `await` 节点输出待审批提案，审批成功后写入记忆/审计；Java/前端同步刷新该事件下的任务列表与地图。
5. **多任务协作**：同一事件可多次生成方案或更新态势，所有信息归档在该事件 ID 下，便于态势汇总与对上汇报。

## 调整清单
- **LangGraph**：
  * 在入口处（意图处理或 REST API）显式维护 `incident_id`。
  * `RescueTaskGenerationHandler`：若上下文已有事件 ID，则跳过 `_build_incident_payload` 对 `create_incident` 的调用，直接构造 `RescueScenarioPayload` 并发布。
  * 图节点 `rescue_task_generate_node` 改为走 handler（带 `ws_notify`），替换旧 `rescue_task_generate_agent`。
- **Java**：
  * 保持现有事件/任务逻辑；若需要可在场景 payload `extra.eventType` 中保留小写字符串（`secondary_hazard` 等）供前端展示。
- **前端**：
  * 继续基于事件卡片展示任务与地图实体；确保 `scope` 包含当前角色（默认 commander）。

## 最新实现校验（2025-02-14）
- 代码路径：`src/emergency_agents/intent/handlers/rescue_task_generation.py` 在缺少会话事件时自动写入常量 `RESCUE_DEMO_INCIDENT_ID = "fef8469f-5f78-4dd4-8825-dbc915d1b630"`，日志关键字 `rescue_task_using_default_incident`/`rescue_notify_using_default_incident` 可确认使用情况。
- `ws_notify` 阶段同样回退到该常量，仅执行 `publish_rescue_scenario`，不再调用 orchestrator `create_incident`。
- 单元测试：`tests/intent/test_rescue_task_generation_handler.py::test_rescue_task_generation_requires_incident` 校验默认事件写入；`test_rescue_task_generation_happy_path`、`test_rescue_simulation_text_only` 覆盖正常路径。
- **2025-11-01 更新**：`plan_generator_agent` 对齐同一策略，若外部未附带 `incident_id`，直接回退到 `RESCUE_DEMO_INCIDENT_ID` 并仅推送场景，彻底移除自动调用 `/api/incidents`。对应测试 `tests/agents/test_plan_generator.py::test_plan_generator_pushes_orchestrator` 已同步校验“无创建、仍推送”路径。该常量统一定义在 `src/emergency_agents/constants.py`，便于后续集中调整。

## 验收
1. 手工创建事件：`/web-api/api/incidents`（已验证返回 201 且实体写入）。
2. 调用 LangGraph 生成方案 → 查看 `temp/server.log` 出现 `rescue_scenario_publish_success`。
3. Java 日志出现 `rescue_scenario_publish_*`，并向 `/topic/scenario.task.triggered` 推送消息。
4. 前端登录 `commander` 角色自动弹窗、刷新实体，任务归属仍为原事件。

遵循事件主导模式，可避免 AI/前端两条数据流割裂，实现真正的“事件统一、任务协同”。
