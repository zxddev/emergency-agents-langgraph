# 战术救援子图拆分与入口差异说明

## 代码位置
- 战术救援子图：`emergency-agents-langgraph/src/emergency_agents/graph/rescue_tactical_app.py`
- 救援任务处理器：`emergency-agents-langgraph/src/emergency_agents/intent/handlers/rescue_task_generation.py`
- 主流程入口：`emergency-agents-langgraph/src/emergency_agents/api/intent_processor.py`
- FastAPI 启动配置：`emergency-agents-langgraph/src/emergency_agents/api/main.py`

## 触发入口矩阵

| 入口来源 | 场景说明 | 是否调用 Orchestrator 广播 | 前端动作 | 备注 |
| --- | --- | --- | --- | --- |
| **传感器 / 无人机 / 机器狗 / 外部 APP** | 设备自动发现救援目标或外部系统上报 | ✅ 推送 `/api/v1/rescue/scenario`，广播至 `/topic/scenario.task.triggered` | 各席位订阅 STOMP → `handleEntityList(entityIds)` 落图、弹窗、播报 | 用于广域告警，须通知全部角色 |
| **指挥员手动地图标注** | 指挥席在地图圈定目标并输入态势 | ❌ 不广播；本地生成实体与方案草稿 | 当前席位直接落图、打开方案面板，其他席位仅必要提醒 | 拒绝噪声，如需同步其它席位，确认后发送“任务已生成”通知 |
| **指挥员语音标注（ASR）** | 语音描述救援点，自动标注 | ❌ 不广播；ASR→实体→方案草稿 | 自动切视角、弹窗、展示方案 | 突出“一句话搞定”，如需同步则确认后发送通知型广播 |

> 若语音/手动标注需要同步其他席位，可在指挥员确认“生成救援任务”后发送简化通知（仅任务状态/文本提醒），不再重复推送实体列表与方案内容。

## 改造总结
- 原 `RescueTaskGraphRunner` 内联流程拆分为独立 `RescueTacticalGraph`，支持 `invoke` 恢复。
- `RescueTaskGenerationHandler` 仅负责依赖装配，节点调度与（可选）广播推送统一由子图处理。
- 主 `RescueState` 状态图入口改为 `situation`，避免和意图识别耦合。
- 机器人狗语音控制迁移到 `VoiceControlGraph`：`process_intent_core` 识别 `device_control_robotdog` 后构造语义指令，返回 `robotdog_control` 回执。
- FastAPI 在启动阶段注册三条子图（意图、救援、语音控制），REST 与 WebSocket 复用。
- **入口差异处理：**
  - 设备/外部上报 → `_push_to_orchestrator` 生成 `RescueScenarioPayload`，连同实体 ID 广播。
  - 地图手动标注 → 直接创建实体（`type=rescue_target` 等），返回 `ui_actions` 打开方案面板；广播由指挥员确认后再触发。
  - 语音标注 → ASR 结果立即写实体且返回方案草稿 + UI 指令，不经广播。

## 推送与渲染链路摘要
1. **广播链路（自动发现 / 外部上报）**
   1. `RescueTaskGenerationHandler` → `_push_to_orchestrator` → Java `RescueScenarioService.publish`。
   2. Java `EventScenarioService` 广播 `/topic/scenario.task.triggered`，payload 包含 `entityIds`、`scope`、`extra.action`。
   3. 前端 `EntityWebSocketClient` 订阅 → `ai-broadcast.jsx` 校验 `scope` → `handleEntityList(entityIds)` → `handleEntityListType` 渲染地图（含自动 flyTo）。
2. **本地链路（语音 / 手动标注）**
   1. LangGraph 生成实体并写入 DB（TODO：补充实体写入接口）。
   2. `process_intent_core` / 语音 WebSocket 返回 `ui_actions`（`fly_to`、`open_plan_panel`、`show_toast` 等），前端立即执行。
   3. 指挥员点击“生成救援任务”后，如需通知其他席位，仅发送“任务已生成/请关注”类文本广播，不重复推送实体与方案正文。

## 日志与指标
- 广播链路沿用既有日志：`rescue_scenario_publish_attempt`、`rescue_scenario_publish_success`、`orchestrator_http_post`。
- 语音控制保留 `robotdog_voice_control_failed`、`robotdog_control` 等日志。
- **待新增（语音/手动标注）日志：**
  - `local_rescue_entity_created`：记录实体 ID、坐标、来源、席位。
  - `rescue_ui_actions_emitted`：记录返回给前端的 UI 指令列表。
- Prometheus 指标沿用 `mem0` 系列；后续可新增 `rescue_plan_generation_seconds` 监控端到端耗时。

## TODO / 后续开发指引
1. **实体写入接口**：提供指挥席本地调用，保证语音/手动标注生成的实体与广播链路结构一致（包含 `layerCode`、`type`、`geometry`、`properties`）。
2. **UI Action 协议**：LangGraph 需返回 `ui_actions`（视角跳转、打开方案面板、展示提示等），前端统一消费。
3. **任务确认 API**：指挥员确认“生成救援任务”后，调用 REST 接口更新草稿状态并（可选）发送简化通知广播（仅包含任务编号、目标摘要等提示信息）。
4. **日志补充**：实现上述本地链路时同步打印 `local_rescue_entity_created`、`rescue_ui_actions_emitted` 等结构化日志。
5. **演示准备**：结合 `/docs/新业务逻辑md/救援场景推送链路.md`，完成语音/手动标注的地图联动与方案面板展示，确保乌镇峰会演示可体现“AI 推理链 + 人机协同”。
