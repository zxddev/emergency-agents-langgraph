# 救援协调方案生成 - 技术设计方案

## 1. 业务需求

### 1.1 核心功能
创建一个API端点,根据当前所有救援点的进度状态,由AI生成专业级别的救援协调方案。

### 1.2 业务定义(基于数据库分析)

**救援点 (Rescue Point)**:
- 定义: `operational.entities` 表中 `entity_type='rescue_target'` 的实体
- 包含: 被困人员位置、灾害现场、次生灾害点等
- 存储: PostGIS `geometry` 字段记录空间位置, JSONB `properties` 记录详细信息

**进度 (Progress)**:
- 任务完成度: `operational.tasks.progress` (0-100百分比)
- 任务状态: `operational.tasks.status` (pending/in_progress/completed/failed)
- 事件状态: `operational.events.status` (pending/active/resolved/cancelled)
- 任务阶段: `operational.missions.phase` (preparation/transit/recon/rescue/evaluation)

**关系模型**:
```
events (事件) ──┬──> missions (救援行动) via source_event_id
               │
               ├──> tasks (任务) via event_id
               │
               └──> event_entities ──> entities (实体)
                                         ↑
tasks (任务) ────────────────────────────┘ via target_entity_id
```

### 1.3 输入/输出

**输入**:
- `incident_id` (可选): 事件ID,如未指定则查询所有活跃事件
- `mission_id` (可选): 任务ID,如未指定则查询所有活跃任务
- `time_range` (可选): 时间范围筛选

**输出**:
```python
{
  "coordination_plan": {
    "summary": {
      "total_rescue_points": 5,
      "high_priority_count": 2,
      "overall_progress": 45.2,  # 加权平均进度
      "critical_issues": ["资源不足", "道路阻断"]
    },
    "rescue_points": [
      {
        "entity_id": "uuid",
        "location": {"lat": 31.68, "lon": 103.85},
        "name": "目标区域A",
        "priority": 95,  # AI评估的优先级
        "current_status": {
          "tasks_total": 3,
          "tasks_completed": 1,
          "overall_progress": 33.3,
          "blocking_issues": []
        },
        "recommendations": {
          "next_actions": ["增派救援队", "调配挖掘设备"],
          "resource_allocation": {...},
          "estimated_completion": "2025-11-04T18:00:00Z"
        }
      }
    ],
    "resource_coordination": {
      "teams": [...],  # 救援队分配建议
      "equipment": [...],  # 装备调配建议
      "routes": [...]  # 路线优化建议
    },
    "risk_assessment": {
      "current_risks": [...],
      "mitigation_strategies": [...]
    },
    "decision_rationale": "..."  # AI决策依据(可解释性)
  },
  "metadata": {
    "generated_at": "2025-11-03T12:00:00Z",
    "data_snapshot": {...},  # 输入数据快照
    "ai_model": "glm-4-flash",
    "confidence_score": 0.87
  }
}
```

## 2. 技术架构

### 2.1 系统组件

```
API Endpoint (/rescue/coordination/plan)
    ↓
CoordinationPlanHandler (意图处理器)
    ↓
coordination_plan_app.py (LangGraph 子图)
    ↓
┌──────────────────────────────────────┐
│ 1. data_collection_node              │  查询数据库
│    - RescuePointDAO (新建)            │
│    - 汇总 entities/events/tasks/missions │
├──────────────────────────────────────┤
│ 2. priority_analysis_node            │  AI评估优先级
│    - 基于伤亡、紧急度、资源可达性      │
├──────────────────────────────────────┤
│ 3. resource_allocation_node          │  资源分配建议
│    - KG查询可用救援队/装备           │
│    - RAG检索类似案例                 │
├──────────────────────────────────────┤
│ 4. risk_assessment_node              │  风险评估
│    - 次生灾害预测                    │
│    - 阻塞因素识别                    │
├──────────────────────────────────────┤
│ 5. plan_generation_node              │  方案生成
│    - 综合所有分析结果                │
│    - LLM生成结构化方案               │
└──────────────────────────────────────┘
```

### 2.2 数据访问层 (DAO)

**新建 RescuePointDAO** (`src/emergency_agents/db/dao.py`):

```python
@dataclass
class RescuePointSummary:
    """救援点摘要数据"""
    entity_id: str
    entity_name: str
    location: dict  # {"lat": float, "lon": float}
    properties: dict  # JSONB properties

    # 关联的事件
    event_id: str | None
    event_title: str | None
    event_status: str | None
    event_priority: int | None

    # 关联的任务
    tasks: list[dict]  # [{"task_id", "status", "progress", "description"}]

    # 关联的救援行动
    mission_id: str | None
    mission_phase: str | None
    mission_status: str | None


class RescuePointDAO:
    """救援点数据访问对象"""

    def __init__(self, pool: AsyncConnectionPool[DictRow]):
        self.pool = pool

    async def fetch_all_active_rescue_points(
        self,
        incident_id: str | None = None,
        mission_id: str | None = None
    ) -> list[RescuePointSummary]:
        """查询所有活跃的救援点及其关联数据

        SQL逻辑:
        1. 从 entities 表查询 entity_type='rescue_target'
        2. 通过 event_entities 关联到 events
        3. 通过 tasks.target_entity_id 关联任务
        4. 通过 events.id 关联到 missions
        5. 筛选条件: events.status='active', missions.status='active'
        """
        query = """
        SELECT
            e.id AS entity_id,
            e.properties->>'name' AS entity_name,
            ST_Y(e.location::geometry) AS lat,
            ST_X(e.location::geometry) AS lon,
            e.properties,

            ev.id AS event_id,
            ev.title AS event_title,
            ev.status AS event_status,
            ev.priority AS event_priority,

            m.id AS mission_id,
            m.phase AS mission_phase,
            m.status AS mission_status,

            json_agg(
                json_build_object(
                    'task_id', t.id,
                    'status', t.status,
                    'progress', t.progress,
                    'description', t.description
                )
            ) FILTER (WHERE t.id IS NOT NULL) AS tasks
        FROM operational.entities e
        LEFT JOIN operational.event_entities ee ON e.id = ee.entity_id
        LEFT JOIN operational.events ev ON ee.event_id = ev.id
        LEFT JOIN operational.tasks t ON t.target_entity_id = e.id
        LEFT JOIN operational.missions m ON m.source_event_id = ev.id
        WHERE e.entity_type = 'rescue_target'
          AND (ev.status = 'active' OR ev.status IS NULL)
          AND (m.status = 'active' OR m.status IS NULL)
          AND ($1::uuid IS NULL OR ev.id = $1)
          AND ($2::uuid IS NULL OR m.id = $2)
        GROUP BY e.id, ev.id, m.id
        ORDER BY ev.priority DESC NULLS LAST, e.created_at DESC
        """

        async with self.pool.connection() as conn:
            cursor = await conn.execute(
                query,
                (incident_id, mission_id)
            )
            rows = await cursor.fetchall()

            return [
                RescuePointSummary(
                    entity_id=row["entity_id"],
                    entity_name=row["entity_name"],
                    location={"lat": row["lat"], "lon": row["lon"]},
                    properties=row["properties"],
                    event_id=row["event_id"],
                    event_title=row["event_title"],
                    event_status=row["event_status"],
                    event_priority=row["event_priority"],
                    tasks=row["tasks"] or [],
                    mission_id=row["mission_id"],
                    mission_phase=row["mission_phase"],
                    mission_status=row["mission_status"],
                )
                for row in rows
            ]
```

### 2.3 LangGraph 子图

**新建 coordination_plan_app.py** (`src/emergency_agents/graph/coordination_plan_app.py`):

```python
from __future__ import annotations
from typing import Any, Dict, Literal
from typing_extensions import Required, NotRequired, TypedDict
from langgraph.graph import StateGraph


class CoordinationPlanState(TypedDict):
    """救援协调方案生成状态"""

    # 输入字段
    incident_id: NotRequired[str]
    mission_id: NotRequired[str]
    user_id: Required[str]

    # 数据收集阶段
    rescue_points: NotRequired[list[Dict[str, Any]]]
    raw_data_summary: NotRequired[Dict[str, Any]]

    # 分析阶段
    priority_scores: NotRequired[Dict[str, float]]  # entity_id -> score
    resource_analysis: NotRequired[Dict[str, Any]]
    risk_analysis: NotRequired[Dict[str, Any]]

    # 输出字段
    coordination_plan: NotRequired[Dict[str, Any]]
    metadata: NotRequired[Dict[str, Any]]


async def build_coordination_plan_app(
    postgres_dsn: str,
    pool: AsyncConnectionPool[DictRow],
    kg_service: KGService,
    rag_pipeline: RagPipeline,
    llm_client: Any,
    llm_model: str,
) -> Any:
    """构建救援协调方案生成子图"""

    state_graph = StateGraph(CoordinationPlanState)

    # 节点1: 数据收集
    async def data_collection_node(state: CoordinationPlanState) -> Dict[str, Any]:
        """查询所有救援点及关联数据"""
        dao = RescuePointDAO(pool)
        rescue_points = await dao.fetch_all_active_rescue_points(
            incident_id=state.get("incident_id"),
            mission_id=state.get("mission_id"),
        )

        # 转换为字典格式
        rescue_points_data = [
            {
                "entity_id": rp.entity_id,
                "name": rp.entity_name,
                "location": rp.location,
                "event_priority": rp.event_priority,
                "tasks": rp.tasks,
                "mission_phase": rp.mission_phase,
            }
            for rp in rescue_points
        ]

        return {
            "rescue_points": rescue_points_data,
            "raw_data_summary": {
                "total_count": len(rescue_points_data),
                "data_timestamp": datetime.now(timezone.utc).isoformat(),
            }
        }

    # 节点2: 优先级分析 (AI评估)
    async def priority_analysis_node(state: CoordinationPlanState) -> Dict[str, Any]:
        """基于多维度因素评估救援点优先级"""
        rescue_points = state.get("rescue_points", [])

        # 构造AI提示词
        prompt = f"""
你是应急救援指挥专家。请分析以下救援点的优先级:

{json.dumps(rescue_points, ensure_ascii=False, indent=2)}

评估因素:
1. 事件优先级(0-100)
2. 伤亡情况(properties中的casualties)
3. 任务完成度(tasks的progress)
4. 时间紧迫性(created_at)
5. 救援难度(地形、可达性)

输出JSON格式:
{{
  "priority_scores": {{"entity_id": score, ...}},
  "rationale": "..."
}}
"""

        response = await llm_client.chat.completions.create(
            model=llm_model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0,
        )

        result = safe_json_parse(response.choices[0].message.content)
        return {"priority_scores": result.get("priority_scores", {})}

    # 节点3: 资源分配建议
    async def resource_allocation_node(state: CoordinationPlanState) -> Dict[str, Any]:
        """基于KG和RAG生成资源分配建议"""
        # KG查询可用救援队
        teams_query = """
        MATCH (t:RescueTeam)
        WHERE t.status = 'available'
        RETURN t.id, t.name, t.capabilities, t.location
        """
        teams = await kg_service.execute_query(teams_query)

        # RAG检索类似救援案例
        cases = await rag_pipeline.retrieve_and_rerank(
            query="多点救援资源分配案例",
            top_k=3,
            domain="案例",
        )

        # AI生成分配建议
        prompt = f"""
可用救援队: {teams}
历史案例: {cases}
救援点: {state.get('rescue_points')}
优先级: {state.get('priority_scores')}

生成资源分配方案(JSON):
{{
  "team_assignments": [...],
  "equipment_allocation": [...],
  "route_optimization": [...]
}}
"""
        # ... LLM调用

        return {"resource_analysis": result}

    # 节点4: 风险评估
    async def risk_assessment_node(state: CoordinationPlanState) -> Dict[str, Any]:
        """识别当前风险和阻塞因素"""
        # ... 类似逻辑
        return {"risk_analysis": result}

    # 节点5: 方案生成
    async def plan_generation_node(state: CoordinationPlanState) -> Dict[str, Any]:
        """综合所有分析,生成最终方案"""
        # 整合所有中间结果
        final_prompt = f"""
你是应急救援总指挥。基于以下分析生成协调方案:

数据摘要: {state['raw_data_summary']}
优先级评估: {state['priority_scores']}
资源分析: {state['resource_analysis']}
风险评估: {state['risk_analysis']}

生成专业级救援协调方案(JSON):
{{
  "summary": {{...}},
  "rescue_points": [...],
  "resource_coordination": {{...}},
  "risk_assessment": {{...}},
  "decision_rationale": "..."
}}

要求:
1. 专业术语准确
2. 决策有理有据
3. 可操作性强
4. 考虑风险预案
"""

        response = await llm_client.chat.completions.create(
            model=llm_model,
            messages=[{"role": "user", "content": final_prompt}],
            temperature=0,
        )

        plan = safe_json_parse(response.choices[0].message.content)

        return {
            "coordination_plan": plan,
            "metadata": {
                "generated_at": datetime.now(timezone.utc).isoformat(),
                "ai_model": llm_model,
                "data_snapshot": state.get("raw_data_summary"),
            }
        }

    # 构建状态图
    state_graph.add_node("data_collection", data_collection_node)
    state_graph.add_node("priority_analysis", priority_analysis_node)
    state_graph.add_node("resource_allocation", resource_allocation_node)
    state_graph.add_node("risk_assessment", risk_assessment_node)
    state_graph.add_node("plan_generation", plan_generation_node)

    state_graph.set_entry_point("data_collection")
    state_graph.add_edge("data_collection", "priority_analysis")
    state_graph.add_edge("priority_analysis", "resource_allocation")
    state_graph.add_edge("resource_allocation", "risk_assessment")
    state_graph.add_edge("risk_assessment", "plan_generation")
    state_graph.add_edge("plan_generation", "__end__")

    # 编译子图(需要checkpoint持久化)
    from emergency_agents.graph.checkpoint_utils import create_async_postgres_checkpointer

    checkpointer, close_cb = await create_async_postgres_checkpointer(
        dsn=postgres_dsn,
        schema="coordination_plan_checkpoint",
        min_size=1,
        max_size=3,
    )

    compiled = state_graph.compile(checkpointer=checkpointer)
    setattr(compiled, "_checkpoint_close", close_cb)

    return compiled
```

### 2.4 意图处理器

**新建 CoordinationPlanHandler** (`src/emergency_agents/intent/handlers/coordination_plan.py`):

```python
from emergency_agents.intent.handlers.base import IntentHandler


class CoordinationPlanHandler(IntentHandler):
    """救援协调方案生成处理器"""

    def __init__(
        self,
        pool: AsyncConnectionPool[DictRow],
        kg_service: KGService,
        rag_pipeline: RagPipeline,
        llm_client: Any,
        llm_model: str,
        postgres_dsn: str,
    ):
        self.pool = pool
        self.kg_service = kg_service
        self.rag_pipeline = rag_pipeline
        self.llm_client = llm_client
        self.llm_model = llm_model
        self.postgres_dsn = postgres_dsn
        self._app = None

    async def initialize(self):
        """延迟初始化LangGraph子图"""
        if self._app is None:
            self._app = await build_coordination_plan_app(
                postgres_dsn=self.postgres_dsn,
                pool=self.pool,
                kg_service=self.kg_service,
                rag_pipeline=self.rag_pipeline,
                llm_client=self.llm_client,
                llm_model=self.llm_model,
            )

    async def handle(self, intent: Dict[str, Any]) -> Dict[str, Any]:
        """处理救援协调方案生成意图"""
        await self.initialize()

        slots = intent.get("slots", {})

        # 构造初始状态
        init_state: CoordinationPlanState = {
            "incident_id": slots.get("incident_id"),
            "mission_id": slots.get("mission_id"),
            "user_id": intent.get("user_id", "unknown"),
        }

        # 配置LangGraph执行
        config = {
            "configurable": {
                "thread_id": f"coordination-{uuid.uuid4()}",
                "checkpoint_ns": f"user-{init_state['user_id']}",
            }
        }

        # 执行子图
        result = await self._app.ainvoke(init_state, config=config)

        # 返回格式化结果
        return {
            "success": True,
            "plan": result.get("coordination_plan"),
            "metadata": result.get("metadata"),
        }
```

### 2.5 API端点

**添加到 main.py** (`src/emergency_agents/api/main.py`):

```python
@app.post("/rescue/coordination/plan")
async def generate_coordination_plan(
    request: Request,
    incident_id: str | None = None,
    mission_id: str | None = None,
) -> Dict[str, Any]:
    """生成救援协调方案

    Args:
        incident_id: 事件ID(可选,未指定则查询所有活跃事件)
        mission_id: 任务ID(可选,未指定则查询所有活跃任务)

    Returns:
        {
          "success": true,
          "plan": {...},  # 详细方案内容
          "metadata": {...}  # 元数据
        }
    """
    try:
        # 构造意图对象
        intent = {
            "intent_type": "rescue-coordination-plan",
            "slots": {
                "incident_id": incident_id,
                "mission_id": mission_id,
            },
            "user_id": "api-user",  # TODO: 从认证中获取
        }

        # 调用处理器
        handler = await get_handler("rescue-coordination-plan")
        result = await handler.handle(intent)

        return result

    except Exception as e:
        logger.error("coordination_plan_failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

## 3. 实施步骤

### 3.1 数据层
- [ ] 在 `dao.py` 中添加 `RescuePointSummary` 数据类
- [ ] 在 `dao.py` 中实现 `RescuePointDAO` 类
- [ ] 编写单元测试 `test_rescue_point_dao.py`

### 3.2 子图层
- [ ] 创建 `coordination_plan_app.py` 文件
- [ ] 实现 5 个节点函数
- [ ] 配置 LangGraph 状态流转
- [ ] 配置 PostgreSQL checkpoint 持久化

### 3.3 处理器层
- [ ] 创建 `coordination_plan.py` handler
- [ ] 在 `registry.py` 中注册处理器
- [ ] 在 `intent_orchestrator_app.py` 的路由表中添加映射

### 3.4 API层
- [ ] 在 `main.py` 中添加 `/rescue/coordination/plan` 端点
- [ ] 添加请求/响应模型(Pydantic)
- [ ] 编写API文档

### 3.5 测试
- [ ] 单元测试: DAO查询逻辑
- [ ] 集成测试: 完整子图流程
- [ ] API测试: 端到端场景

## 4. 质量保证

### 4.1 强类型要求
- 所有函数必须有完整类型注解
- 使用 `TypedDict` + `Required`/`NotRequired`
- 数据库结果必须映射到 `@dataclass`

### 4.2 幂等性保证
- 所有节点函数支持幂等执行
- 检查 state 中是否已有结果,有则直接返回

### 4.3 错误处理
- 不使用 fallback/降级逻辑
- 数据库错误直接暴露
- LLM错误记录审计日志

### 4.4 可观测性
- 关键位置添加结构化日志(structlog)
- 记录 AI 决策依据(decision_rationale)
- 审计日志记录所有执行轨迹

## 5. 示例调用

```bash
# 查询所有活跃救援点的协调方案
curl -X POST http://localhost:8008/rescue/coordination/plan

# 查询特定事件的协调方案
curl -X POST http://localhost:8008/rescue/coordination/plan?incident_id=xxx-uuid

# 查询特定任务的协调方案
curl -X POST http://localhost:8008/rescue/coordination/plan?mission_id=xxx-uuid
```

## 6. 未来扩展

- 支持人工审批中断点(类似 app.py 的 await 节点)
- 支持方案版本对比(checkpoint历史)
- 支持多种输出格式(PDF报告、语音播报)
- 支持实时数据推送(WebSocket)
