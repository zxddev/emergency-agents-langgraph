# 鼎桥机器狗控制链路调研

## 1. 现有链路（前端 → Java → 适配器 → 机器狗）

1. **前端控制入口**（`emergency-rescue-brain`）
   - API 封装：`src/api/control.js` 调用 `POST /adapter-hub/api/v3/device-access/control`。
   - 请求体格式：由 UI 组装 `CommonDeviceCommand` 结构（含 `deviceId`、`deviceVendor`、`commandType`、`params.action`），通过 `axios` 请求发送。

2. **适配器 REST 层**（`emergency-adapter-hub`）
   - 控制器：`adapter-device-accessor/src/main/java/com/cykj/adapterhub/accessor/controller/DeviceAccessController.java:22-52`。
   - 核心方法：`control()` 直接调用 `DeviceCommandAccessService.sendDeviceCommand()`。

3. **命令统一转换**
   - 服务：`DeviceCommandAccessService`（同路径 1-232 行）。
   - 功能：根据 `deviceVendor` 分流；对鼎桥（`VendorType.DQ_DOG`）使用 `DQDogCommandTranslator.toCommandMotion()` 将通用动作映射到鼎桥命令字。
   - 行为：
     - `ensureControllable()` 查询遥测，必要时调用 `DQNotificationService.dogPermissionQuery()` 抢占控制权。
     - MOVE 命令：组装 `MotionParam`，调用 `DQMessageService.motion()`；`stop`、`stop2` 走单独接口。

4. **鼎桥适配层**
   - 命令转换：`adapter-vendor-dqdog/src/main/java/com/cykj/adapterhub/dqdog/trans/DQDogCommandTranslator.java`。
   - 下发服务：`DQDogControlService` / `DQMessageService` 等通过 `DQDogSocketIOClient`（同模块）与鼎桥 Socket.IO 服务通信。
   - 日志：`log.info("机器狗步态切换 ...")` 等，记录设备 ID、动作、响应。

## 2. 与语音子图的集成要点

1. **Python 侧 Adapter 调用**
   - 已有 HTTP 客户端：`emergency-agents-langgraph/src/emergency_agents/external/adapter_client.py`，具备 `AdapterHubClient.send_device_command()`，默认命中 `/api/v3/device-access/control`。
   - 当前 RobotDog 命令构造函数 `build_robotdog_move_command()` 与 Java 适配器使用一致的动作枚举（`forward/turnLeft/stop` 等）。

2. **语音子图输出规范**
   - 需生成与前端一致的 `CommonDeviceCommand`（或直接调用 `AdapterHubClient`，采用 `deviceId`、`deviceVendor='dingqiaoDog'`、`commandType='move'`、`params={'action': ...}`）。
   - 为保持兼容，建议新增 `WeaponAction` → 鼎桥动作映射与 `deviceVendor` 常量，统一在 `control_commands.py` 管理。

3. **确认反馈**
   - 鼎桥停止命令存在 `stop`、`stop2` 两种模式（`DQDogCommandTranslator` 中映射），语音端需支持口令区分，如“立即急停”和“缓停”。
   - 语音确认环节可依据 `DeviceCommandAccessService` 中 `ensureControllable` 的日志判断是否拿到控制权，必要时给操作者语音反馈。

4. **调用流程建议**
   1. 语音解析得到 `deviceVendor=dingqiaoDog`、`action=forward` 等参数。
   2. 通过 `AdapterHubClient` POST 控制命令（保持内容与前端一致）。
   3. 使用 `audit_trail` 记录关键日志：
      - `command_built`：记录动作。
      - `adapter_dispatch`：记录 HTTP 状态与响应 payload。
      - `control_result`：根据响应成功/失败更新状态。

## 3. 语音指令落地步骤

1. **命令词库设计**
   - `前进 / 向前` → `forward`
   - `后退 / 倒退` → `backward`
   - `左转 / 右转` → `turnleft/turnright`
   - `站立 / 起立` → `standup`
   - `趴下 / 坐下` → `sitdown`
   - `急停 / 停止` → `stop`（必要时扩展 `stop2` 对应“缓停”）

2. **对接流程**
   - 语音子图 `dispatch_command` 节点调用 `AdapterHubClient.send_device_command()`。
   - 若返回 4xx/5xx，记录 `voice_control_error`，并提示“机器狗未取得控制权”或具体错误。
   - 成功后将 `AdapterHubClient` 响应透出给 Java（前端可通过 WebSocket 监听 adapter hub 反馈）。

3. **回推前端状态**
   - 目前前端通过 STOMP (`src/utils/stompClient.js:241`) 接收设备状态。语音控制完成后需确保 adapter hub 正常广播状态变更（已有 `DeviceCommandAccessService` 中 `sendDeviceCommand` 的日志，配合现有 Kafka 流可验证）。

## 4. 后续补充

- 与 Java 团队确认 `CommonDeviceCommand` 中是否必须提供 `deviceVendor`（目前写死 `'dingqiaoDog'`）。
- 关注 `ensureControllable` 的权限抢占日志，必要时在语音侧读取 `adapter` 返回的提示信息，让用户知道控制权来源。
- 语音场景落地前需与前端约定指令确认弹窗/语音播报策略，避免误操作。

